mirrorsöð
(function(a,b){
"use strict";
var c=a.Array;
var d=a.isNaN;
var e=a.JSON.stringify;
var f=a.Map.prototype.entries;
var g=(new a.Map).entries().next;
var h=(new a.Set).values().next;
var i=a.Set.prototype.values;
var j={
UNDEFINED_TYPE:'undefined',
NULL_TYPE:'null',
BOOLEAN_TYPE:'boolean',
NUMBER_TYPE:'number',
STRING_TYPE:'string',
SYMBOL_TYPE:'symbol',
OBJECT_TYPE:'object',
FUNCTION_TYPE:'function',
REGEXP_TYPE:'regexp',
ERROR_TYPE:'error',
PROPERTY_TYPE:'property',
INTERNAL_PROPERTY_TYPE:'internalProperty',
FRAME_TYPE:'frame',
SCRIPT_TYPE:'script',
CONTEXT_TYPE:'context',
SCOPE_TYPE:'scope',
PROMISE_TYPE:'promise',
MAP_TYPE:'map',
SET_TYPE:'set',
ITERATOR_TYPE:'iterator',
GENERATOR_TYPE:'generator',
}
function MakeMirror(k){
var l;
if((k===(void 0))){
l=new UndefinedMirror();
}else if((k===null)){
l=new NullMirror();
}else if((typeof(k)==='boolean')){
l=new BooleanMirror(k);
}else if((typeof(k)==='number')){
l=new NumberMirror(k);
}else if((typeof(k)==='string')){
l=new StringMirror(k);
}else if((typeof(k)==='symbol')){
l=new SymbolMirror(k);
}else if((%_IsArray(k))){
l=new ArrayMirror(k);
}else if((%IsDate(k))){
l=new DateMirror(k);
}else if((%IsFunction(k))){
l=new FunctionMirror(k);
}else if(%IsRegExp(k)){
l=new RegExpMirror(k);
}else if((%_ClassOf(k)==='Error')){
l=new ErrorMirror(k);
}else if((%_ClassOf(k)==='Script')){
l=new ScriptMirror(k);
}else if((%_IsJSMap(k))||(%_IsJSWeakMap(k))){
l=new MapMirror(k);
}else if((%_IsJSSet(k))||(%_IsJSWeakSet(k))){
l=new SetMirror(k);
}else if((%_ClassOf(k)==='Map Iterator')||(%_ClassOf(k)==='Set Iterator')){
l=new IteratorMirror(k);
}else if(%is_promise(k)){
l=new PromiseMirror(k);
}else if((%_ClassOf(k)==='Generator')){
l=new GeneratorMirror(k);
}else{
l=new ObjectMirror(k,j.OBJECT_TYPE);
}
return l;
}
function GetUndefinedMirror(){
return MakeMirror((void 0));
}
function inherits(m,n){
var o=function(){};
o.prototype=n.prototype;
m.super_=n.prototype;
m.prototype=new o();
m.prototype.constructor=m;
}
var p=80;
var q={};
q.Data=0;
q.Accessor=1;
var r={};
r.None=0;
r.ReadOnly=1;
r.DontEnum=2;
r.DontDelete=4;
var s={Global:0,
Local:1,
With:2,
Closure:3,
Catch:4,
Block:5,
Script:6,
Eval:7,
Module:8,
};
function Mirror(t){
this.type_=t;
}
Mirror.prototype.type=function(){
return this.type_;
};
Mirror.prototype.isValue=function(){
return this instanceof ValueMirror;
};
Mirror.prototype.isUndefined=function(){
return this instanceof UndefinedMirror;
};
Mirror.prototype.isNull=function(){
return this instanceof NullMirror;
};
Mirror.prototype.isBoolean=function(){
return this instanceof BooleanMirror;
};
Mirror.prototype.isNumber=function(){
return this instanceof NumberMirror;
};
Mirror.prototype.isString=function(){
return this instanceof StringMirror;
};
Mirror.prototype.isSymbol=function(){
return this instanceof SymbolMirror;
};
Mirror.prototype.isObject=function(){
return this instanceof ObjectMirror;
};
Mirror.prototype.isFunction=function(){
return this instanceof FunctionMirror;
};
Mirror.prototype.isUnresolvedFunction=function(){
return this instanceof UnresolvedFunctionMirror;
};
Mirror.prototype.isArray=function(){
return this instanceof ArrayMirror;
};
Mirror.prototype.isDate=function(){
return this instanceof DateMirror;
};
Mirror.prototype.isRegExp=function(){
return this instanceof RegExpMirror;
};
Mirror.prototype.isError=function(){
return this instanceof ErrorMirror;
};
Mirror.prototype.isPromise=function(){
return this instanceof PromiseMirror;
};
Mirror.prototype.isGenerator=function(){
return this instanceof GeneratorMirror;
};
Mirror.prototype.isProperty=function(){
return this instanceof PropertyMirror;
};
Mirror.prototype.isInternalProperty=function(){
return this instanceof InternalPropertyMirror;
};
Mirror.prototype.isFrame=function(){
return this instanceof FrameMirror;
};
Mirror.prototype.isScript=function(){
return this instanceof ScriptMirror;
};
Mirror.prototype.isContext=function(){
return this instanceof ContextMirror;
};
Mirror.prototype.isScope=function(){
return this instanceof ScopeMirror;
};
Mirror.prototype.isMap=function(){
return this instanceof MapMirror;
};
Mirror.prototype.isSet=function(){
return this instanceof SetMirror;
};
Mirror.prototype.isIterator=function(){
return this instanceof IteratorMirror;
};
Mirror.prototype.toText=function(){
return"#<"+this.constructor.name+">";
};
function ValueMirror(t,k){
%_Call(Mirror,this,t);
this.value_=k;
}
inherits(ValueMirror,Mirror);
ValueMirror.prototype.isPrimitive=function(){
var t=this.type();
return t==='undefined'||
t==='null'||
t==='boolean'||
t==='number'||
t==='string'||
t==='symbol';
};
ValueMirror.prototype.value=function(){
return this.value_;
};
function UndefinedMirror(){
%_Call(ValueMirror,this,j.UNDEFINED_TYPE,(void 0));
}
inherits(UndefinedMirror,ValueMirror);
UndefinedMirror.prototype.toText=function(){
return'undefined';
};
function NullMirror(){
%_Call(ValueMirror,this,j.NULL_TYPE,null);
}
inherits(NullMirror,ValueMirror);
NullMirror.prototype.toText=function(){
return'null';
};
function BooleanMirror(k){
%_Call(ValueMirror,this,j.BOOLEAN_TYPE,k);
}
inherits(BooleanMirror,ValueMirror);
BooleanMirror.prototype.toText=function(){
return this.value_?'true':'false';
};
function NumberMirror(k){
%_Call(ValueMirror,this,j.NUMBER_TYPE,k);
}
inherits(NumberMirror,ValueMirror);
NumberMirror.prototype.toText=function(){
return %NumberToString(this.value_);
};
function StringMirror(k){
%_Call(ValueMirror,this,j.STRING_TYPE,k);
}
inherits(StringMirror,ValueMirror);
StringMirror.prototype.length=function(){
return this.value_.length;
};
StringMirror.prototype.getTruncatedValue=function(u){
if(u!=-1&&this.length()>u){
return this.value_.substring(0,u)+
'... (length: '+this.length()+')';
}
return this.value_;
};
StringMirror.prototype.toText=function(){
return this.getTruncatedValue(p);
};
function SymbolMirror(k){
%_Call(ValueMirror,this,j.SYMBOL_TYPE,k);
}
inherits(SymbolMirror,ValueMirror);
SymbolMirror.prototype.description=function(){
return %SymbolDescription(%ValueOf(this.value_));
}
SymbolMirror.prototype.toText=function(){
return %SymbolDescriptiveString(%ValueOf(this.value_));
}
function ObjectMirror(k,t){
t=t||j.OBJECT_TYPE;
%_Call(ValueMirror,this,t,k);
}
inherits(ObjectMirror,ValueMirror);
ObjectMirror.prototype.className=function(){
return %_ClassOf(this.value_);
};
ObjectMirror.prototype.constructorFunction=function(){
return MakeMirror(%DebugGetProperty(this.value_,'constructor'));
};
ObjectMirror.prototype.prototypeObject=function(){
return MakeMirror(%DebugGetProperty(this.value_,'prototype'));
};
ObjectMirror.prototype.protoObject=function(){
return MakeMirror(%DebugGetPrototype(this.value_));
};
ObjectMirror.prototype.hasNamedInterceptor=function(){
var v=%GetInterceptorInfo(this.value_);
return(v&2)!=0;
};
ObjectMirror.prototype.hasIndexedInterceptor=function(){
var v=%GetInterceptorInfo(this.value_);
return(v&1)!=0;
};
ObjectMirror.prototype.propertyNames=function(){
return %GetOwnPropertyKeys(this.value_,0);
};
ObjectMirror.prototype.properties=function(){
var w=this.propertyNames();
var x=new c(w.length);
for(var y=0;y<w.length;y++){
x[y]=this.property(w[y]);
}
return x;
};
ObjectMirror.prototype.internalProperties=function(){
return ObjectMirror.GetInternalProperties(this.value_);
}
ObjectMirror.prototype.property=function(z){
var A=%DebugGetPropertyDetails(this.value_,z);
if(A){
return new PropertyMirror(this,z,A);
}
return GetUndefinedMirror();
};
ObjectMirror.prototype.lookupProperty=function(k){
var x=this.properties();
for(var y=0;y<x.length;y++){
var B=x[y];
if(B.propertyType()==q.Data){
if(B.value_===k.value_){
return B;
}
}
}
return GetUndefinedMirror();
};
ObjectMirror.prototype.referencedBy=function(C){
var D=%DebugReferencedBy(this.value_,
Mirror.prototype,C||0);
for(var y=0;y<D.length;y++){
D[y]=MakeMirror(D[y]);
}
return D;
};
ObjectMirror.prototype.toText=function(){
var z;
var m=this.constructorFunction();
if(!m.isFunction()){
z=this.className();
}else{
z=m.name();
if(!z){
z=this.className();
}
}
return'#<'+z+'>';
};
ObjectMirror.GetInternalProperties=function(k){
var x=%DebugGetInternalProperties(k);
var D=[];
for(var y=0;y<x.length;y+=2){
D.push(new InternalPropertyMirror(x[y],x[y+1]));
}
return D;
}
function FunctionMirror(k){
%_Call(ObjectMirror,this,k,j.FUNCTION_TYPE);
this.resolved_=true;
}
inherits(FunctionMirror,ObjectMirror);
FunctionMirror.prototype.resolved=function(){
return this.resolved_;
};
FunctionMirror.prototype.name=function(){
return %FunctionGetName(this.value_);
};
FunctionMirror.prototype.debugName=function(){
return %FunctionGetDebugName(this.value_);
}
FunctionMirror.prototype.inferredName=function(){
return %FunctionGetInferredName(this.value_);
};
FunctionMirror.prototype.source=function(){
if(this.resolved()){
return %FunctionToString(this.value_);
}
};
FunctionMirror.prototype.script=function(){
if(this.resolved()){
if(this.script_){
return this.script_;
}
var E=%FunctionGetScript(this.value_);
if(E){
return this.script_=MakeMirror(E);
}
}
};
FunctionMirror.prototype.sourcePosition_=function(){
if(this.resolved()){
return %FunctionGetScriptSourcePosition(this.value_);
}
};
FunctionMirror.prototype.sourceLocation=function(){
if(this.resolved()){
var E=this.script();
if(E){
return E.locationFromPosition(this.sourcePosition_(),true);
}
}
};
FunctionMirror.prototype.constructedBy=function(F){
if(this.resolved()){
var D=%DebugConstructedBy(this.value_,F||0);
for(var y=0;y<D.length;y++){
D[y]=MakeMirror(D[y]);
}
return D;
}else{
return[];
}
};
FunctionMirror.prototype.scopeCount=function(){
if(this.resolved()){
if((this.scopeCount_===(void 0))){
this.scopeCount_=%GetFunctionScopeCount(this.value());
}
return this.scopeCount_;
}else{
return 0;
}
};
FunctionMirror.prototype.scope=function(G){
if(this.resolved()){
return new ScopeMirror((void 0),this,(void 0),G);
}
};
FunctionMirror.prototype.toText=function(){
return this.source();
};
FunctionMirror.prototype.context=function(){
if(this.resolved()){
if(!this._context)
this._context=new ContextMirror(%FunctionGetContextData(this.value_));
return this._context;
}
};
function UnresolvedFunctionMirror(k){
%_Call(ValueMirror,this,j.FUNCTION_TYPE,k);
this.propertyCount_=0;
this.elementCount_=0;
this.resolved_=false;
}
inherits(UnresolvedFunctionMirror,FunctionMirror);
UnresolvedFunctionMirror.prototype.className=function(){
return'Function';
};
UnresolvedFunctionMirror.prototype.constructorFunction=function(){
return GetUndefinedMirror();
};
UnresolvedFunctionMirror.prototype.prototypeObject=function(){
return GetUndefinedMirror();
};
UnresolvedFunctionMirror.prototype.protoObject=function(){
return GetUndefinedMirror();
};
UnresolvedFunctionMirror.prototype.name=function(){
return this.value_;
};
UnresolvedFunctionMirror.prototype.debugName=function(){
return this.value_;
};
UnresolvedFunctionMirror.prototype.inferredName=function(){
return(void 0);
};
UnresolvedFunctionMirror.prototype.propertyNames=function(H,I){
return[];
};
function ArrayMirror(k){
%_Call(ObjectMirror,this,k);
}
inherits(ArrayMirror,ObjectMirror);
ArrayMirror.prototype.length=function(){
return this.value_.length;
};
ArrayMirror.prototype.indexedPropertiesFromRange=function(opt_from_index,
opt_to_index){
var J=opt_from_index||0;
var K=opt_to_index||this.length()-1;
if(J>K)return new c();
var L=new c(K-J+1);
for(var y=J;y<=K;y++){
var A=%DebugGetPropertyDetails(this.value_,(%_ToString(y)));
var k;
if(A){
k=new PropertyMirror(this,y,A);
}else{
k=GetUndefinedMirror();
}
L[y-J]=k;
}
return L;
};
function DateMirror(k){
%_Call(ObjectMirror,this,k);
}
inherits(DateMirror,ObjectMirror);
DateMirror.prototype.toText=function(){
var M=e(this.value_);
return M.substring(1,M.length-1);
};
function RegExpMirror(k){
%_Call(ObjectMirror,this,k,j.REGEXP_TYPE);
}
inherits(RegExpMirror,ObjectMirror);
RegExpMirror.prototype.source=function(){
return this.value_.source;
};
RegExpMirror.prototype.global=function(){
return this.value_.global;
};
RegExpMirror.prototype.ignoreCase=function(){
return this.value_.ignoreCase;
};
RegExpMirror.prototype.multiline=function(){
return this.value_.multiline;
};
RegExpMirror.prototype.sticky=function(){
return this.value_.sticky;
};
RegExpMirror.prototype.unicode=function(){
return this.value_.unicode;
};
RegExpMirror.prototype.toText=function(){
return"/"+this.source()+"/";
};
function ErrorMirror(k){
%_Call(ObjectMirror,this,k,j.ERROR_TYPE);
}
inherits(ErrorMirror,ObjectMirror);
ErrorMirror.prototype.message=function(){
return this.value_.message;
};
ErrorMirror.prototype.toText=function(){
var N;
try{
N=%ErrorToString(this.value_);
}catch(e){
N='#<Error>';
}
return N;
};
function PromiseMirror(k){
%_Call(ObjectMirror,this,k,j.PROMISE_TYPE);
}
inherits(PromiseMirror,ObjectMirror);
function PromiseGetStatus_(k){
var O=%PromiseStatus(k);
if(O==0)return"pending";
if(O==1)return"resolved";
return"rejected";
}
function PromiseGetValue_(k){
return %PromiseResult(k);
}
PromiseMirror.prototype.status=function(){
return PromiseGetStatus_(this.value_);
};
PromiseMirror.prototype.promiseValue=function(){
return MakeMirror(PromiseGetValue_(this.value_));
};
function MapMirror(k){
%_Call(ObjectMirror,this,k,j.MAP_TYPE);
}
inherits(MapMirror,ObjectMirror);
MapMirror.prototype.entries=function(P){
var D=[];
if((%_IsJSWeakMap(this.value_))){
var Q=%GetWeakMapEntries(this.value_,P||0);
for(var y=0;y<Q.length;y+=2){
D.push({
key:Q[y],
value:Q[y+1]
});
}
return D;
}
var R=%_Call(f,this.value_);
var S;
while((!P||D.length<P)&&
!(S=R.next()).done){
D.push({
key:S.value[0],
value:S.value[1]
});
}
return D;
};
function SetMirror(k){
%_Call(ObjectMirror,this,k,j.SET_TYPE);
}
inherits(SetMirror,ObjectMirror);
function IteratorGetValues_(R,T,P){
var D=[];
var S;
while((!P||D.length<P)&&
!(S=%_Call(T,R)).done){
D.push(S.value);
}
return D;
}
SetMirror.prototype.values=function(P){
if((%_IsJSWeakSet(this.value_))){
return %GetWeakSetValues(this.value_,P||0);
}
var R=%_Call(i,this.value_);
return IteratorGetValues_(R,h,P);
};
function IteratorMirror(k){
%_Call(ObjectMirror,this,k,j.ITERATOR_TYPE);
}
inherits(IteratorMirror,ObjectMirror);
IteratorMirror.prototype.preview=function(P){
if((%_ClassOf(this.value_)==='Map Iterator')){
return IteratorGetValues_(%MapIteratorClone(this.value_),
g,
P);
}else if((%_ClassOf(this.value_)==='Set Iterator')){
return IteratorGetValues_(%SetIteratorClone(this.value_),
h,
P);
}
};
function GeneratorMirror(k){
%_Call(ObjectMirror,this,k,j.GENERATOR_TYPE);
}
inherits(GeneratorMirror,ObjectMirror);
function GeneratorGetStatus_(k){
var U=%GeneratorGetContinuation(k);
if(U<-1)return"running";
if(U==-1)return"closed";
return"suspended";
}
GeneratorMirror.prototype.status=function(){
return GeneratorGetStatus_(this.value_);
};
GeneratorMirror.prototype.sourcePosition_=function(){
return %GeneratorGetSourcePosition(this.value_);
};
GeneratorMirror.prototype.sourceLocation=function(){
var V=this.sourcePosition_();
if(!(V===(void 0))){
var E=this.func().script();
if(E){
return E.locationFromPosition(V,true);
}
}
};
GeneratorMirror.prototype.func=function(){
if(!this.func_){
this.func_=MakeMirror(%GeneratorGetFunction(this.value_));
}
return this.func_;
};
GeneratorMirror.prototype.receiver=function(){
if(!this.receiver_){
this.receiver_=MakeMirror(%GeneratorGetReceiver(this.value_));
}
return this.receiver_;
};
GeneratorMirror.prototype.scopeCount=function(){
return %GetGeneratorScopeCount(this.value());
};
GeneratorMirror.prototype.scope=function(G){
return new ScopeMirror((void 0),(void 0),this,G);
};
GeneratorMirror.prototype.allScopes=function(){
var W=[];
for(let y=0;y<this.scopeCount();y++){
W.push(this.scope(y));
}
return W;
};
function PropertyMirror(l,z,A){
%_Call(Mirror,this,j.PROPERTY_TYPE);
this.mirror_=l;
this.name_=z;
this.value_=A[0];
this.details_=A[1];
this.is_interceptor_=A[2];
if(A.length>3){
this.exception_=A[3];
this.getter_=A[4];
this.setter_=A[5];
}
}
inherits(PropertyMirror,Mirror);
PropertyMirror.prototype.isReadOnly=function(){
return(this.attributes()&r.ReadOnly)!=0;
};
PropertyMirror.prototype.isEnum=function(){
return(this.attributes()&r.DontEnum)==0;
};
PropertyMirror.prototype.canDelete=function(){
return(this.attributes()&r.DontDelete)==0;
};
PropertyMirror.prototype.name=function(){
return this.name_;
};
PropertyMirror.prototype.toText=function(){
if((typeof(this.name_)==='symbol'))return %SymbolDescriptiveString(this.name_);
return this.name_;
};
PropertyMirror.prototype.isIndexed=function(){
for(var y=0;y<this.name_.length;y++){
if(this.name_[y]<'0'||'9'<this.name_[y]){
return false;
}
}
return true;
};
PropertyMirror.prototype.value=function(){
return MakeMirror(this.value_,false);
};
PropertyMirror.prototype.isException=function(){
return this.exception_?true:false;
};
PropertyMirror.prototype.attributes=function(){
return %DebugPropertyAttributesFromDetails(this.details_);
};
PropertyMirror.prototype.propertyType=function(){
return %DebugPropertyKindFromDetails(this.details_);
};
PropertyMirror.prototype.hasGetter=function(){
return this.getter_?true:false;
};
PropertyMirror.prototype.hasSetter=function(){
return this.setter_?true:false;
};
PropertyMirror.prototype.getter=function(){
if(this.hasGetter()){
return MakeMirror(this.getter_);
}else{
return GetUndefinedMirror();
}
};
PropertyMirror.prototype.setter=function(){
if(this.hasSetter()){
return MakeMirror(this.setter_);
}else{
return GetUndefinedMirror();
}
};
PropertyMirror.prototype.isNative=function(){
return this.is_interceptor_||
((this.propertyType()==q.Accessor)&&
!this.hasGetter()&&!this.hasSetter());
};
function InternalPropertyMirror(z,k){
%_Call(Mirror,this,j.INTERNAL_PROPERTY_TYPE);
this.name_=z;
this.value_=k;
}
inherits(InternalPropertyMirror,Mirror);
InternalPropertyMirror.prototype.name=function(){
return this.name_;
};
InternalPropertyMirror.prototype.value=function(){
return MakeMirror(this.value_,false);
};
var X=0;
var Y=1;
var Z=2;
var aa=3;
var ab=4;
var ac=5;
var ad=6;
var ae=7;
var af=8;
var ag=9;
var ah=10;
var ai=0;
var aj=1;
var ak=2;
var al=1<<0;
var am=1<<1;
var an=7<<2;
function FrameDetails(ao,G){
this.break_id_=ao;
this.details_=%GetFrameDetails(ao,G);
}
FrameDetails.prototype.frameId=function(){
%CheckExecutionState(this.break_id_);
return this.details_[X];
};
FrameDetails.prototype.receiver=function(){
%CheckExecutionState(this.break_id_);
return this.details_[Y];
};
FrameDetails.prototype.func=function(){
%CheckExecutionState(this.break_id_);
return this.details_[Z];
};
FrameDetails.prototype.script=function(){
%CheckExecutionState(this.break_id_);
return this.details_[aa];
};
FrameDetails.prototype.isConstructCall=function(){
%CheckExecutionState(this.break_id_);
return this.details_[ae];
};
FrameDetails.prototype.isAtReturn=function(){
%CheckExecutionState(this.break_id_);
return this.details_[af];
};
FrameDetails.prototype.isDebuggerFrame=function(){
%CheckExecutionState(this.break_id_);
var ap=al;
return(this.details_[ag]&ap)==ap;
};
FrameDetails.prototype.isOptimizedFrame=function(){
%CheckExecutionState(this.break_id_);
var ap=am;
return(this.details_[ag]&ap)==ap;
};
FrameDetails.prototype.isInlinedFrame=function(){
return this.inlinedFrameIndex()>0;
};
FrameDetails.prototype.inlinedFrameIndex=function(){
%CheckExecutionState(this.break_id_);
var ap=an;
return(this.details_[ag]&ap)>>2;
};
FrameDetails.prototype.argumentCount=function(){
%CheckExecutionState(this.break_id_);
return this.details_[ab];
};
FrameDetails.prototype.argumentName=function(G){
%CheckExecutionState(this.break_id_);
if(G>=0&&G<this.argumentCount()){
return this.details_[ah+
G*ak+
ai];
}
};
FrameDetails.prototype.argumentValue=function(G){
%CheckExecutionState(this.break_id_);
if(G>=0&&G<this.argumentCount()){
return this.details_[ah+
G*ak+
aj];
}
};
FrameDetails.prototype.localCount=function(){
%CheckExecutionState(this.break_id_);
return this.details_[ac];
};
FrameDetails.prototype.sourcePosition=function(){
%CheckExecutionState(this.break_id_);
return this.details_[ad];
};
FrameDetails.prototype.localName=function(G){
%CheckExecutionState(this.break_id_);
if(G>=0&&G<this.localCount()){
var aq=ah+
this.argumentCount()*ak;
return this.details_[aq+
G*ak+
ai];
}
};
FrameDetails.prototype.localValue=function(G){
%CheckExecutionState(this.break_id_);
if(G>=0&&G<this.localCount()){
var aq=ah+
this.argumentCount()*ak;
return this.details_[aq+
G*ak+
aj];
}
};
FrameDetails.prototype.returnValue=function(){
%CheckExecutionState(this.break_id_);
var ar=
ah+
(this.argumentCount()+this.localCount())*ak;
if(this.details_[af]){
return this.details_[ar];
}
};
FrameDetails.prototype.scopeCount=function(){
if((this.scopeCount_===(void 0))){
this.scopeCount_=%GetScopeCount(this.break_id_,this.frameId());
}
return this.scopeCount_;
};
function FrameMirror(ao,G){
%_Call(Mirror,this,j.FRAME_TYPE);
this.break_id_=ao;
this.index_=G;
this.details_=new FrameDetails(ao,G);
}
inherits(FrameMirror,Mirror);
FrameMirror.prototype.details=function(){
return this.details_;
};
FrameMirror.prototype.index=function(){
return this.index_;
};
FrameMirror.prototype.func=function(){
if(this.func_){
return this.func_;
}
var ap=this.details_.func();
if((%IsFunction(ap))){
return this.func_=MakeMirror(ap);
}else{
return new UnresolvedFunctionMirror(ap);
}
};
FrameMirror.prototype.script=function(){
if(!this.script_){
this.script_=MakeMirror(this.details_.script());
}
return this.script_;
}
FrameMirror.prototype.receiver=function(){
return MakeMirror(this.details_.receiver());
};
FrameMirror.prototype.isConstructCall=function(){
return this.details_.isConstructCall();
};
FrameMirror.prototype.isAtReturn=function(){
return this.details_.isAtReturn();
};
FrameMirror.prototype.isDebuggerFrame=function(){
return this.details_.isDebuggerFrame();
};
FrameMirror.prototype.isOptimizedFrame=function(){
return this.details_.isOptimizedFrame();
};
FrameMirror.prototype.isInlinedFrame=function(){
return this.details_.isInlinedFrame();
};
FrameMirror.prototype.inlinedFrameIndex=function(){
return this.details_.inlinedFrameIndex();
};
FrameMirror.prototype.argumentCount=function(){
return this.details_.argumentCount();
};
FrameMirror.prototype.argumentName=function(G){
return this.details_.argumentName(G);
};
FrameMirror.prototype.argumentValue=function(G){
return MakeMirror(this.details_.argumentValue(G));
};
FrameMirror.prototype.localCount=function(){
return this.details_.localCount();
};
FrameMirror.prototype.localName=function(G){
return this.details_.localName(G);
};
FrameMirror.prototype.localValue=function(G){
return MakeMirror(this.details_.localValue(G));
};
FrameMirror.prototype.returnValue=function(){
return MakeMirror(this.details_.returnValue());
};
FrameMirror.prototype.sourcePosition=function(){
return this.details_.sourcePosition();
};
FrameMirror.prototype.sourceLocation=function(){
var E=this.script();
if(E){
return E.locationFromPosition(this.sourcePosition(),true);
}
};
FrameMirror.prototype.sourceLine=function(){
var as=this.sourceLocation();
if(as){
return as.line;
}
};
FrameMirror.prototype.sourceColumn=function(){
var as=this.sourceLocation();
if(as){
return as.column;
}
};
FrameMirror.prototype.sourceLineText=function(){
var as=this.sourceLocation();
if(as){
return as.sourceText;
}
};
FrameMirror.prototype.scopeCount=function(){
return this.details_.scopeCount();
};
FrameMirror.prototype.scope=function(G){
return new ScopeMirror(this,(void 0),(void 0),G);
};
FrameMirror.prototype.allScopes=function(at){
var au=%GetAllScopesDetails(this.break_id_,
this.details_.frameId(),
this.details_.inlinedFrameIndex(),
!!at);
var D=[];
for(var y=0;y<au.length;++y){
D.push(new ScopeMirror(this,(void 0),(void 0),y,
au[y]));
}
return D;
};
FrameMirror.prototype.evaluate=function(source,throw_on_side_effect=false){
return MakeMirror(%DebugEvaluate(this.break_id_,
this.details_.frameId(),
this.details_.inlinedFrameIndex(),
source,
throw_on_side_effect));
};
FrameMirror.prototype.invocationText=function(){
var D='';
var av=this.func();
var aw=this.receiver();
if(this.isConstructCall()){
D+='new ';
D+=av.name()?av.name():'[anonymous]';
}else if(this.isDebuggerFrame()){
D+='[debugger]';
}else{
var ax=
!aw.className||(aw.className()!='global');
if(ax){
D+=aw.toText();
}
var B=GetUndefinedMirror();
if(aw.isObject()){
for(var ay=aw;
!ay.isNull()&&B.isUndefined();
ay=ay.protoObject()){
B=ay.lookupProperty(av);
}
}
if(!B.isUndefined()){
if(!B.isIndexed()){
if(ax){
D+='.';
}
D+=B.toText();
}else{
D+='[';
D+=B.toText();
D+=']';
}
if(av.name()&&av.name()!=B.name()){
D+='(aka '+av.name()+')';
}
}else{
if(ax){
D+='.';
}
D+=av.name()?av.name():'[anonymous]';
}
}
if(!this.isDebuggerFrame()){
D+='(';
for(var y=0;y<this.argumentCount();y++){
if(y!=0)D+=', ';
if(this.argumentName(y)){
D+=this.argumentName(y);
D+='=';
}
D+=this.argumentValue(y).toText();
}
D+=')';
}
if(this.isAtReturn()){
D+=' returning ';
D+=this.returnValue().toText();
}
return D;
};
FrameMirror.prototype.sourceAndPositionText=function(){
var D='';
var av=this.func();
if(av.resolved()){
var E=av.script();
if(E){
if(E.name()){
D+=E.name();
}else{
D+='[unnamed]';
}
if(!this.isDebuggerFrame()){
var as=this.sourceLocation();
D+=' line ';
D+=!(as===(void 0))?(as.line+1):'?';
D+=' column ';
D+=!(as===(void 0))?(as.column+1):'?';
if(!(this.sourcePosition()===(void 0))){
D+=' (position '+(this.sourcePosition()+1)+')';
}
}
}else{
D+='[no source]';
}
}else{
D+='[unresolved]';
}
return D;
};
FrameMirror.prototype.localsText=function(){
var D='';
var az=this.localCount();
if(az>0){
for(var y=0;y<az;++y){
D+='      var ';
D+=this.localName(y);
D+=' = ';
D+=this.localValue(y).toText();
if(y<az-1)D+='\n';
}
}
return D;
};
FrameMirror.prototype.restart=function(){
var D=%LiveEditRestartFrame(this.break_id_,this.index_);
if((D===(void 0))){
D="Failed to find requested frame";
}
return D;
};
FrameMirror.prototype.toText=function(aA){
var D='';
D+='#'+(this.index()<=9?'0':'')+this.index();
D+=' ';
D+=this.invocationText();
D+=' ';
D+=this.sourceAndPositionText();
if(aA){
D+='\n';
D+=this.localsText();
}
return D;
};
var aB=0;
var aC=1;
var aD=2;
var aE=3;
var aF=4;
var aG=5;
function ScopeDetails(aH,aI,aJ,G,aK){
if(aH){
this.break_id_=aH.break_id_;
this.details_=aK||
%GetScopeDetails(aH.break_id_,
aH.details_.frameId(),
aH.details_.inlinedFrameIndex(),
G);
this.frame_id_=aH.details_.frameId();
this.inlined_frame_id_=aH.details_.inlinedFrameIndex();
}else if(aI){
this.details_=aK||%GetFunctionScopeDetails(aI.value(),G);
this.fun_value_=aI.value();
this.break_id_=(void 0);
}else{
this.details_=
aK||%GetGeneratorScopeDetails(aJ.value(),G);
this.gen_value_=aJ.value();
this.break_id_=(void 0);
}
this.index_=G;
}
ScopeDetails.prototype.type=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aB];
};
ScopeDetails.prototype.object=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aC];
};
ScopeDetails.prototype.name=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aD];
};
ScopeDetails.prototype.startPosition=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aE];
}
ScopeDetails.prototype.endPosition=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aF];
}
ScopeDetails.prototype.func=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
}
return this.details_[aG];
}
ScopeDetails.prototype.setVariableValueImpl=function(z,aL){
var aM;
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
aM=%SetScopeVariableValue(this.break_id_,this.frame_id_,
this.inlined_frame_id_,this.index_,z,aL);
}else if(!(this.fun_value_===(void 0))){
aM=%SetScopeVariableValue(this.fun_value_,null,null,this.index_,
z,aL);
}else{
aM=%SetScopeVariableValue(this.gen_value_,null,null,this.index_,
z,aL);
}
if(!aM)throw %make_error(2,"Failed to set variable value");
};
function ScopeMirror(aH,aI,aJ,G,aK){
%_Call(Mirror,this,j.SCOPE_TYPE);
if(aH){
this.frame_index_=aH.index_;
}else{
this.frame_index_=(void 0);
}
this.scope_index_=G;
this.details_=new ScopeDetails(aH,aI,aJ,G,aK);
}
inherits(ScopeMirror,Mirror);
ScopeMirror.prototype.details=function(){
return this.details_;
};
ScopeMirror.prototype.frameIndex=function(){
return this.frame_index_;
};
ScopeMirror.prototype.scopeIndex=function(){
return this.scope_index_;
};
ScopeMirror.prototype.scopeType=function(){
return this.details_.type();
};
ScopeMirror.prototype.scopeObject=function(){
return MakeMirror(this.details_.object());
};
ScopeMirror.prototype.setVariableValue=function(z,aL){
this.details_.setVariableValueImpl(z,aL);
};
function ScriptMirror(E){
%_Call(Mirror,this,j.SCRIPT_TYPE);
this.script_=E;
this.context_=new ContextMirror(E.context_data);
}
inherits(ScriptMirror,Mirror);
ScriptMirror.prototype.value=function(){
return this.script_;
};
ScriptMirror.prototype.name=function(){
return this.script_.name||this.script_.nameOrSourceURL();
};
ScriptMirror.prototype.id=function(){
return this.script_.id;
};
ScriptMirror.prototype.source=function(){
return this.script_.source;
};
ScriptMirror.prototype.setSource=function(aN){
if(!(typeof(aN)==='string'))throw %make_error(2,"Source is not a string");
%DebugSetScriptSource(this.script_,aN);
};
ScriptMirror.prototype.lineOffset=function(){
return this.script_.line_offset;
};
ScriptMirror.prototype.columnOffset=function(){
return this.script_.column_offset;
};
ScriptMirror.prototype.data=function(){
return this.script_.data;
};
ScriptMirror.prototype.scriptType=function(){
return this.script_.type;
};
ScriptMirror.prototype.compilationType=function(){
return this.script_.compilation_type;
};
ScriptMirror.prototype.lineCount=function(){
return %ScriptLineCount(this.script_);
};
ScriptMirror.prototype.locationFromPosition=function(
position,include_resource_offset){
return this.script_.locationFromPosition(position,include_resource_offset);
};
ScriptMirror.prototype.context=function(){
return this.context_;
};
ScriptMirror.prototype.evalFromScript=function(){
return MakeMirror(this.script_.eval_from_script);
};
ScriptMirror.prototype.evalFromFunctionName=function(){
return MakeMirror(this.script_.eval_from_function_name);
};
ScriptMirror.prototype.evalFromLocation=function(){
var aO=this.evalFromScript();
if(!aO.isUndefined()){
var aP=this.script_.eval_from_script_position;
return aO.locationFromPosition(aP,true);
}
};
ScriptMirror.prototype.toText=function(){
var D='';
D+=this.name();
D+=' (lines: ';
if(this.lineOffset()>0){
D+=this.lineOffset();
D+='-';
D+=this.lineOffset()+this.lineCount()-1;
}else{
D+=this.lineCount();
}
D+=')';
return D;
};
function ContextMirror(aQ){
%_Call(Mirror,this,j.CONTEXT_TYPE);
this.data_=aQ;
}
inherits(ContextMirror,Mirror);
ContextMirror.prototype.data=function(){
return this.data_;
};
b.InstallConstants(a,[
"MakeMirror",MakeMirror,
"ScopeType",s,
"PropertyType",q,
"PropertyAttribute",r,
"Mirror",Mirror,
"ValueMirror",ValueMirror,
"UndefinedMirror",UndefinedMirror,
"NullMirror",NullMirror,
"BooleanMirror",BooleanMirror,
"NumberMirror",NumberMirror,
"StringMirror",StringMirror,
"SymbolMirror",SymbolMirror,
"ObjectMirror",ObjectMirror,
"FunctionMirror",FunctionMirror,
"UnresolvedFunctionMirror",UnresolvedFunctionMirror,
"ArrayMirror",ArrayMirror,
"DateMirror",DateMirror,
"RegExpMirror",RegExpMirror,
"ErrorMirror",ErrorMirror,
"PromiseMirror",PromiseMirror,
"MapMirror",MapMirror,
"SetMirror",SetMirror,
"IteratorMirror",IteratorMirror,
"GeneratorMirror",GeneratorMirror,
"PropertyMirror",PropertyMirror,
"InternalPropertyMirror",InternalPropertyMirror,
"FrameMirror",FrameMirror,
"ScriptMirror",ScriptMirror,
"ScopeMirror",ScopeMirror,
"FrameDetails",FrameDetails,
]);
})

debugî
(function(a,b){
"use strict";
var c=a.FrameMirror;
var d=a.Array;
var e=a.RegExp;
var f=a.isNaN;
var g=a.MakeMirror;
var h=a.Math.min;
var i=a.Mirror;
var j=a.ValueMirror;
var k=10;
var l={};
var m=/^(?:\s*(?:\/\*.*?\*\/)*)*/;
l.DebugEvent={Break:1,
Exception:2,
AfterCompile:3,
CompileError:4,
AsyncTaskEvent:5};
l.ExceptionBreak={Caught:0,
Uncaught:1};
l.StepAction={StepOut:0,
StepNext:1,
StepIn:2};
l.ScriptType={Native:0,
Extension:1,
Normal:2,
Wasm:3};
l.ScriptCompilationType={Host:0,
Eval:1,
JSON:2};
l.ScriptBreakPointType={ScriptId:0,
ScriptName:1,
ScriptRegExp:2};
function ScriptTypeFlag(n){
return(1<<n);
}
var o=0;
var p=1;
var q=[];
var r=[];
var s={
breakPointsActive:{
value:true,
getValue:function(){return this.value;},
setValue:function(t){
this.value=!!t;
%SetBreakPointsActive(this.value);
}
},
breakOnCaughtException:{
getValue:function(){return l.isBreakOnException();},
setValue:function(t){
if(t){
l.setBreakOnException();
}else{
l.clearBreakOnException();
}
}
},
breakOnUncaughtException:{
getValue:function(){return l.isBreakOnUncaughtException();},
setValue:function(t){
if(t){
l.setBreakOnUncaughtException();
}else{
l.clearBreakOnUncaughtException();
}
}
},
};
function MakeBreakPoint(u,v){
var w=new BreakPoint(u,v);
q.push(w);
return w;
}
function BreakPoint(u,v){
this.source_position_=u;
if(v){
this.script_break_point_=v;
}else{
this.number_=p++;
}
this.active_=true;
this.condition_=null;
}
BreakPoint.prototype.number=function(){
return this.number_;
};
BreakPoint.prototype.func=function(){
return this.func_;
};
BreakPoint.prototype.source_position=function(){
return this.source_position_;
};
BreakPoint.prototype.active=function(){
if(this.script_break_point()){
return this.script_break_point().active();
}
return this.active_;
};
BreakPoint.prototype.condition=function(){
if(this.script_break_point()&&this.script_break_point().condition()){
return this.script_break_point().condition();
}
return this.condition_;
};
BreakPoint.prototype.script_break_point=function(){
return this.script_break_point_;
};
BreakPoint.prototype.enable=function(){
this.active_=true;
};
BreakPoint.prototype.disable=function(){
this.active_=false;
};
BreakPoint.prototype.setCondition=function(x){
this.condition_=x;
};
BreakPoint.prototype.isTriggered=function(y){
if(!this.active())return false;
if(this.condition()){
try{
var z=y.frame(0).evaluate(this.condition());
if(!(z instanceof j)||!z.value_){
return false;
}
}catch(e){
return false;
}
}
return true;
};
function IsBreakPointTriggered(A,w){
return w.isTriggered(MakeExecutionState(A));
}
function ScriptBreakPoint(n,script_id_or_name,opt_line,opt_column,
opt_groupId){
this.type_=n;
if(n==l.ScriptBreakPointType.ScriptId){
this.script_id_=script_id_or_name;
}else if(n==l.ScriptBreakPointType.ScriptName){
this.script_name_=script_id_or_name;
}else if(n==l.ScriptBreakPointType.ScriptRegExp){
this.script_regexp_object_=new e(script_id_or_name);
}else{
throw %make_error(2,"Unexpected breakpoint type "+n);
}
this.line_=opt_line||0;
this.column_=opt_column;
this.groupId_=opt_groupId;
this.active_=true;
this.condition_=null;
this.break_points_=[];
}
ScriptBreakPoint.prototype.number=function(){
return this.number_;
};
ScriptBreakPoint.prototype.groupId=function(){
return this.groupId_;
};
ScriptBreakPoint.prototype.type=function(){
return this.type_;
};
ScriptBreakPoint.prototype.script_id=function(){
return this.script_id_;
};
ScriptBreakPoint.prototype.script_name=function(){
return this.script_name_;
};
ScriptBreakPoint.prototype.script_regexp_object=function(){
return this.script_regexp_object_;
};
ScriptBreakPoint.prototype.line=function(){
return this.line_;
};
ScriptBreakPoint.prototype.column=function(){
return this.column_;
};
ScriptBreakPoint.prototype.actual_locations=function(){
var B=[];
for(var C=0;C<this.break_points_.length;C++){
B.push(this.break_points_[C].actual_location);
}
return B;
};
ScriptBreakPoint.prototype.update_positions=function(D,E){
this.line_=D;
this.column_=E;
};
ScriptBreakPoint.prototype.active=function(){
return this.active_;
};
ScriptBreakPoint.prototype.condition=function(){
return this.condition_;
};
ScriptBreakPoint.prototype.enable=function(){
this.active_=true;
};
ScriptBreakPoint.prototype.disable=function(){
this.active_=false;
};
ScriptBreakPoint.prototype.setCondition=function(x){
this.condition_=x;
};
ScriptBreakPoint.prototype.matchesScript=function(F){
if(this.type_==l.ScriptBreakPointType.ScriptId){
return this.script_id_==F.id;
}else{
if(!(F.line_offset<=this.line_&&
this.line_<F.line_offset+%ScriptLineCount(F))){
return false;
}
if(this.type_==l.ScriptBreakPointType.ScriptName){
return this.script_name_==F.nameOrSourceURL();
}else if(this.type_==l.ScriptBreakPointType.ScriptRegExp){
return this.script_regexp_object_.test(F.nameOrSourceURL());
}else{
throw %make_error(2,"Unexpected breakpoint type "+this.type_);
}
}
};
ScriptBreakPoint.prototype.set=function(F){
var E=this.column();
var D=this.line();
if((E===(void 0))){
var G=%ScriptSourceLine(F,D||F.line_offset);
if(!F.sourceColumnStart_){
F.sourceColumnStart_=new d(%ScriptLineCount(F));
}
if((F.sourceColumnStart_[D]===(void 0))){
F.sourceColumnStart_[D]=
G.match(m)[0].length;
}
E=F.sourceColumnStart_[D];
}
var H=l.findScriptSourcePosition(F,this.line(),E);
if((H===null))return;
var w=MakeBreakPoint(H,this);
var I=%SetScriptBreakPoint(F,H,
w);
if((I===(void 0))){
I=H;
}
var J=F.locationFromPosition(I,true);
w.actual_location={line:J.line,
column:J.column,
script_id:F.id};
this.break_points_.push(w);
return w;
};
ScriptBreakPoint.prototype.clear=function(){
var K=[];
for(var C=0;C<q.length;C++){
if(q[C].script_break_point()&&
q[C].script_break_point()===this){
%ClearBreakPoint(q[C]);
}else{
K.push(q[C]);
}
}
q=K;
this.break_points_=[];
};
l.setListener=function(L,M){
if(!(%IsFunction(L))&&!(L===(void 0))&&!(L===null)){
throw %make_type_error(36);
}
%SetDebugEventListener(L,M);
};
l.findScript=function(N){
if((%IsFunction(N))){
return %FunctionGetScript(N);
}else if(%IsRegExp(N)){
var O=this.scripts();
var P=null;
var Q=0;
for(var C in O){
var F=O[C];
if(N.test(F.name)){
P=F;
Q++;
}
}
if(Q==1){
return P;
}else{
return(void 0);
}
}else{
return %GetScript(N);
}
};
l.scriptSource=function(N){
return this.findScript(N).source;
};
l.source=function(R){
if(!(%IsFunction(R)))throw %make_type_error(36);
return %FunctionGetSourceCode(R);
};
l.sourcePosition=function(R){
if(!(%IsFunction(R)))throw %make_type_error(36);
return %FunctionGetScriptSourcePosition(R);
};
l.findFunctionSourceLocation=function(S,T,U){
var F=%FunctionGetScript(S);
var V=%FunctionGetScriptSourcePosition(S);
return %ScriptLocationFromLine(F,T,U,V);
};
l.findScriptSourcePosition=function(F,T,U){
var W=%ScriptLocationFromLine(F,T,U,0);
return W?W.position:null;
};
l.findBreakPoint=function(X,Y){
var w;
for(var C=0;C<q.length;C++){
if(q[C].number()==X){
w=q[C];
if(Y){
q.splice(C,1);
}
break;
}
}
if(w){
return w;
}else{
return this.findScriptBreakPoint(X,Y);
}
};
l.findBreakPointActualLocations=function(X){
for(var C=0;C<r.length;C++){
if(r[C].number()==X){
return r[C].actual_locations();
}
}
for(var C=0;C<q.length;C++){
if(q[C].number()==X){
return[q[C].actual_location];
}
}
return[];
};
l.setBreakPoint=function(S,T,U,Z){
if(!(%IsFunction(S)))throw %make_type_error(36);
if(%FunctionIsAPIFunction(S)){
throw %make_error(2,'Cannot set break point in native code.');
}
var u=
this.findFunctionSourceLocation(S,T,U).position;
var F=%FunctionGetScript(S);
if(F.type==l.ScriptType.Native){
throw %make_error(2,'Cannot set break point in native code.');
}
if(F&&F.id){
var W=F.locationFromPosition(u,false);
return this.setScriptBreakPointById(F.id,
W.line,W.column,
Z);
}else{
var w=MakeBreakPoint(u);
var I=
%SetFunctionBreakPoint(S,u,w);
var J=F.locationFromPosition(I,true);
w.actual_location={line:J.line,
column:J.column,
script_id:F.id};
w.setCondition(Z);
return w.number();
}
};
l.setBreakPointByScriptIdAndPosition=function(script_id,H,
x,enabled)
{
var w=MakeBreakPoint(H);
w.setCondition(x);
if(!enabled){
w.disable();
}
var F=scriptById(script_id);
if(F){
w.actual_position=%SetScriptBreakPoint(F,H,w);
}
return w;
};
l.enableBreakPoint=function(X){
var w=this.findBreakPoint(X,false);
if(w){
w.enable();
}
};
l.disableBreakPoint=function(X){
var w=this.findBreakPoint(X,false);
if(w){
w.disable();
}
};
l.changeBreakPointCondition=function(X,x){
var w=this.findBreakPoint(X,false);
w.setCondition(x);
};
l.clearBreakPoint=function(X){
var w=this.findBreakPoint(X,true);
if(w){
return %ClearBreakPoint(w);
}else{
w=this.findScriptBreakPoint(X,true);
if(!w)throw %make_error(2,'Invalid breakpoint');
}
};
l.clearAllBreakPoints=function(){
for(var C=0;C<q.length;C++){
var w=q[C];
%ClearBreakPoint(w);
}
q=[];
};
l.disableAllBreakPoints=function(){
for(var C=1;C<p;C++){
l.disableBreakPoint(C);
}
%ChangeBreakOnException(l.ExceptionBreak.Caught,false);
%ChangeBreakOnException(l.ExceptionBreak.Uncaught,false);
};
l.findScriptBreakPoint=function(X,Y){
var aa;
for(var C=0;C<r.length;C++){
if(r[C].number()==X){
aa=r[C];
if(Y){
aa.clear();
r.splice(C,1);
}
break;
}
}
return aa;
};
l.setScriptBreakPoint=function(n,script_id_or_name,
T,U,Z,
opt_groupId){
var aa=
new ScriptBreakPoint(n,script_id_or_name,T,U,
opt_groupId);
aa.number_=p++;
aa.setCondition(Z);
r.push(aa);
var O=this.scripts();
for(var C=0;C<O.length;C++){
if(aa.matchesScript(O[C])){
aa.set(O[C]);
}
}
return aa.number();
};
l.setScriptBreakPointById=function(script_id,
T,U,
Z,opt_groupId){
return this.setScriptBreakPoint(l.ScriptBreakPointType.ScriptId,
script_id,T,U,
Z,opt_groupId);
};
l.setScriptBreakPointByName=function(script_name,
T,U,
Z,opt_groupId){
return this.setScriptBreakPoint(l.ScriptBreakPointType.ScriptName,
script_name,T,U,
Z,opt_groupId);
};
l.setScriptBreakPointByRegExp=function(script_regexp,
T,U,
Z,opt_groupId){
return this.setScriptBreakPoint(l.ScriptBreakPointType.ScriptRegExp,
script_regexp,T,U,
Z,opt_groupId);
};
l.enableScriptBreakPoint=function(X){
var aa=this.findScriptBreakPoint(X,false);
aa.enable();
};
l.disableScriptBreakPoint=function(X){
var aa=this.findScriptBreakPoint(X,false);
aa.disable();
};
l.changeScriptBreakPointCondition=function(
X,x){
var aa=this.findScriptBreakPoint(X,false);
aa.setCondition(x);
};
l.scriptBreakPoints=function(){
return r;
};
l.clearStepping=function(){
%ClearStepping();
};
l.setBreakOnException=function(){
return %ChangeBreakOnException(l.ExceptionBreak.Caught,true);
};
l.clearBreakOnException=function(){
return %ChangeBreakOnException(l.ExceptionBreak.Caught,false);
};
l.isBreakOnException=function(){
return!!%IsBreakOnException(l.ExceptionBreak.Caught);
};
l.setBreakOnUncaughtException=function(){
return %ChangeBreakOnException(l.ExceptionBreak.Uncaught,true);
};
l.clearBreakOnUncaughtException=function(){
return %ChangeBreakOnException(l.ExceptionBreak.Uncaught,false);
};
l.isBreakOnUncaughtException=function(){
return!!%IsBreakOnException(l.ExceptionBreak.Uncaught);
};
l.showBreakPoints=function(R,ab){
if(!(%IsFunction(R)))throw %make_error(36);
var ac=ab?this.scriptSource(R):this.source(R);
var ad=ab?0:this.sourcePosition(R);
var B=%GetBreakLocations(R);
if(!B)return ac;
B.sort(function(ae,af){return ae-af;});
var ag="";
var ah=0;
var ai;
for(var C=0;C<B.length;C++){
ai=B[C]-ad;
ag+=ac.slice(ah,ai);
ag+="[B"+C+"]";
ah=ai;
}
ai=ac.length;
ag+=ac.substring(ah,ai);
return ag;
};
l.scripts=function(){
return %DebugGetLoadedScripts();
};
function scriptById(aj){
var O=l.scripts();
for(var F of O){
if(F.id==aj)return F;
}
return(void 0);
};
l.debuggerFlags=function(){
return s;
};
l.MakeMirror=g;
function MakeExecutionState(A){
return new ExecutionState(A);
}
function ExecutionState(A){
this.break_id=A;
this.selected_frame=0;
}
ExecutionState.prototype.prepareStep=function(ak){
if(ak===l.StepAction.StepIn||
ak===l.StepAction.StepOut||
ak===l.StepAction.StepNext){
return %PrepareStep(this.break_id,ak);
}
throw %make_type_error(36);
};
ExecutionState.prototype.evaluateGlobal=function(ac){
return g(%DebugEvaluateGlobal(this.break_id,ac));
};
ExecutionState.prototype.frameCount=function(){
return %GetFrameCount(this.break_id);
};
ExecutionState.prototype.frame=function(al){
if(al==null)al=this.selected_frame;
if(al<0||al>=this.frameCount()){
throw %make_type_error(35);
}
return new c(this.break_id,al);
};
ExecutionState.prototype.setSelectedFrame=function(am){
var C=(%_ToNumber(am));
if(C<0||C>=this.frameCount()){
throw %make_type_error(35);
}
this.selected_frame=C;
};
ExecutionState.prototype.selectedFrame=function(){
return this.selected_frame;
};
function MakeBreakEvent(A,an){
return new BreakEvent(A,an);
}
function BreakEvent(A,an){
this.frame_=new c(A,0);
this.break_points_hit_=an;
}
BreakEvent.prototype.eventType=function(){
return l.DebugEvent.Break;
};
BreakEvent.prototype.func=function(){
return this.frame_.func();
};
BreakEvent.prototype.sourceLine=function(){
return this.frame_.sourceLine();
};
BreakEvent.prototype.sourceColumn=function(){
return this.frame_.sourceColumn();
};
BreakEvent.prototype.sourceLineText=function(){
return this.frame_.sourceLineText();
};
BreakEvent.prototype.breakPointsHit=function(){
return this.break_points_hit_;
};
function MakeExceptionEvent(A,ao,ap,aq){
return new ExceptionEvent(A,ao,ap,aq);
}
function ExceptionEvent(A,ao,ap,aq){
this.exec_state_=new ExecutionState(A);
this.exception_=ao;
this.uncaught_=ap;
this.promise_=aq;
}
ExceptionEvent.prototype.eventType=function(){
return l.DebugEvent.Exception;
};
ExceptionEvent.prototype.exception=function(){
return this.exception_;
};
ExceptionEvent.prototype.uncaught=function(){
return this.uncaught_;
};
ExceptionEvent.prototype.promise=function(){
return this.promise_;
};
ExceptionEvent.prototype.func=function(){
return this.exec_state_.frame(0).func();
};
ExceptionEvent.prototype.sourceLine=function(){
return this.exec_state_.frame(0).sourceLine();
};
ExceptionEvent.prototype.sourceColumn=function(){
return this.exec_state_.frame(0).sourceColumn();
};
ExceptionEvent.prototype.sourceLineText=function(){
return this.exec_state_.frame(0).sourceLineText();
};
function MakeCompileEvent(F,n){
return new CompileEvent(F,n);
}
function CompileEvent(F,n){
this.script_=g(F);
this.type_=n;
}
CompileEvent.prototype.eventType=function(){
return this.type_;
};
CompileEvent.prototype.script=function(){
return this.script_;
};
function MakeScriptObject_(F,ar){
var as={id:F.id(),
name:F.name(),
lineOffset:F.lineOffset(),
columnOffset:F.columnOffset(),
lineCount:F.lineCount(),
};
if(!(F.data()===(void 0))){
as.data=F.data();
}
if(ar){
as.source=F.source();
}
return as;
}
function MakeAsyncTaskEvent(n,at){
return new AsyncTaskEvent(n,at);
}
function AsyncTaskEvent(n,at){
this.type_=n;
this.id_=at;
}
AsyncTaskEvent.prototype.type=function(){
return this.type_;
}
AsyncTaskEvent.prototype.id=function(){
return this.id_;
}
b.InstallConstants(a,[
"Debug",l,
"BreakEvent",BreakEvent,
"CompileEvent",CompileEvent,
"BreakPoint",BreakPoint,
]);
b.InstallConstants(b,[
"MakeExecutionState",MakeExecutionState,
"MakeExceptionEvent",MakeExceptionEvent,
"MakeBreakEvent",MakeBreakEvent,
"MakeCompileEvent",MakeCompileEvent,
"MakeAsyncTaskEvent",MakeAsyncTaskEvent,
"IsBreakPointTriggered",IsBreakPointTriggered,
]);
})

 liveedit}ì
(function(a,b){
"use strict";
var c=a.Debug.findScriptSourcePosition;
var d=a.Array;
var e=a.Math.floor;
var f=a.Math.max;
var g=a.SyntaxError;
var h;
function ApplyPatchMultiChunk(script,diff_array,new_source,preview_only,
change_log){
var i=script.source;
var j=GatherCompileInfo(i,script);
var k=BuildCodeInfoTree(j);
var l=new PosTranslator(diff_array);
MarkChangedFunctions(k,l.GetChunks());
FindLiveSharedInfos(k,script);
var m;
try{
m=GatherCompileInfo(new_source,script);
}catch(e){
var n=
new Failure("Failed to compile new version of script: "+e);
if(e instanceof g){
var o={
type:"liveedit_compile_error",
syntaxErrorMessage:e.message
};
CopyErrorPositionToDetails(e,o);
n.details=o;
}
throw n;
}
var p=m.reduce(
(max,info)=>f(max,info.function_literal_id),0);
var q=BuildCodeInfoTree(m);
FindCorrespondingFunctions(k,q);
var r=new d();
var s=new d();
var t=new d();
var u=new d();
function HarvestTodo(v){
function CollectDamaged(w){
s.push(w);
for(var x=0;x<w.children.length;x++){
CollectDamaged(w.children[x]);
}
}
function CollectNew(y){
for(var x=0;x<y.length;x++){
t.push(y[x]);
CollectNew(y[x].children);
}
}
if(v.status==h.DAMAGED){
CollectDamaged(v);
return;
}
if(v.status==h.UNCHANGED){
u.push(v);
}else if(v.status==h.SOURCE_CHANGED){
u.push(v);
}else if(v.status==h.CHANGED){
r.push(v);
CollectNew(v.unmatched_new_nodes);
}
for(var x=0;x<v.children.length;x++){
HarvestTodo(v.children[x]);
}
}
var z={
change_tree:DescribeChangeTree(k),
textual_diff:{
old_len:i.length,
new_len:new_source.length,
chunks:diff_array
},
updated:false
};
if(preview_only){
return z;
}
HarvestTodo(k);
var A=new d();
var B=new d();
for(var x=0;x<r.length;x++){
var C=r[x].live_shared_function_infos;
var D=
r[x].corresponding_node.info.shared_function_info;
if(C){
for(var E=0;E<C.length;E++){
A.push(C[E]);
B.push(D);
}
}
}
var F=
CheckStackActivations(A,
B,
change_log);
z.stack_modified=F!=0;
var G;
if(s.length==0){
%LiveEditReplaceScript(script,new_source,null);
G=(void 0);
}else{
var H=CreateNameForOldScript(script);
G=%LiveEditReplaceScript(script,new_source,H);
var I=new d();
change_log.push({linked_to_old_script:I});
for(var x=0;x<s.length;x++){
LinkToOldScript(s[x],G,
I);
}
z.created_script_name=H;
}
for(var x=0;x<r.length;x++){
PatchFunctionCode(r[x],change_log);
}
var J=new d();
change_log.push({position_patched:J});
for(var x=0;x<u.length;x++){
PatchPositions(u[x],diff_array,
J);
if(u[x].live_shared_function_infos){
var K=
u[x]
.corresponding_node.info.function_literal_id;
u[x].live_shared_function_infos.forEach(function(
info){
%LiveEditFunctionSourceUpdated(
info.raw_array,K);
});
}
}
%LiveEditFixupScript(script,p);
for(var x=0;x<t.length;x++){
%LiveEditFunctionSetScript(
t[x].info.shared_function_info,script);
}
z.updated=true;
return z;
}
function GatherCompileInfo(L,M){
var N=%LiveEditGatherCompileInfo(M,L);
var O=new d();
var P=new d();
for(var x=0;x<N.length;x++){
var Q=new FunctionCompileInfo(N[x]);
%LiveEditFunctionSetScript(Q.shared_function_info,(void 0));
O.push(Q);
P.push(x);
}
for(var x=0;x<O.length;x++){
var R=x;
for(var E=x+1;E<O.length;E++){
if(O[R].start_position>O[E].start_position){
R=E;
}
}
if(R!=x){
var S=O[R];
var T=P[R];
O[R]=O[x];
P[R]=P[x];
O[x]=S;
P[x]=T;
}
}
var U=0;
function ResetIndexes(V,W){
var X=-1;
while(U<O.length&&
O[U].outer_index==W){
var Y=U;
O[Y].outer_index=V;
if(X!=-1){
O[X].next_sibling_index=Y;
}
X=Y;
U++;
ResetIndexes(Y,P[Y]);
}
if(X!=-1){
O[X].next_sibling_index=-1;
}
}
ResetIndexes(-1,-1);
Assert(U==O.length);
return O;
}
function PatchFunctionCode(v,Z){
var D=v.corresponding_node.info;
if(v.live_shared_function_infos){
v.live_shared_function_infos.forEach(function(aa){
%LiveEditReplaceFunctionCode(D.raw_array,
aa.raw_array);
for(var x=0;x<v.children.length;x++){
if(v.children[x].corresponding_node){
var ab=
v.children[x].corresponding_node.info.
shared_function_info;
if(v.children[x].live_shared_function_infos){
v.children[x].live_shared_function_infos.
forEach(function(ac){
%LiveEditReplaceRefToNestedFunction(
aa.info,
ab,
ac.info);
});
}
}
}
});
Z.push({function_patched:D.function_name});
}else{
Z.push({function_patched:D.function_name,
function_info_not_found:true});
}
}
function LinkToOldScript(ad,G,ae){
if(ad.live_shared_function_infos){
ad.live_shared_function_infos.
forEach(function(Q){
%LiveEditFunctionSetScript(Q.info,G);
});
ae.push({name:ad.info.function_name});
}else{
ae.push(
{name:ad.info.function_name,not_found:true});
}
}
function Assert(af,ag){
if(!af){
if(ag){
throw"Assert "+ag;
}else{
throw"Assert";
}
}
}
function DiffChunk(ah,ai,aj,ak){
this.pos1=ah;
this.pos2=ai;
this.len1=aj;
this.len2=ak;
}
function PosTranslator(al){
var am=new d();
var an=0;
for(var x=0;x<al.length;x+=3){
var ao=al[x];
var ap=ao+an;
var aq=al[x+1];
var ar=al[x+2];
am.push(new DiffChunk(ao,ap,aq-ao,
ar-ap));
an=ar-aq;
}
this.chunks=am;
}
PosTranslator.prototype.GetChunks=function(){
return this.chunks;
};
PosTranslator.prototype.Translate=function(as,at){
var au=this.chunks;
if(au.length==0||as<au[0].pos1){
return as;
}
var av=0;
var aw=au.length-1;
while(av<aw){
var ax=e((av+aw)/2);
if(as<au[ax+1].pos1){
aw=ax;
}else{
av=ax+1;
}
}
var ay=au[av];
if(as>=ay.pos1+ay.len1){
return as+ay.pos2+ay.len2-ay.pos1-ay.len1;
}
if(!at){
at=PosTranslator.DefaultInsideChunkHandler;
}
return at(as,ay);
};
PosTranslator.DefaultInsideChunkHandler=function(as,az){
Assert(false,"Cannot translate position in changed area");
};
PosTranslator.ShiftWithTopInsideChunkHandler=
function(as,az){
return as-az.pos1+az.pos2;
};
var h={
UNCHANGED:"unchanged",
SOURCE_CHANGED:"source changed",
CHANGED:"changed",
DAMAGED:"damaged"
};
function CodeInfoTreeNode(aA,aB,aC){
this.info=aA;
this.children=aB;
this.array_index=aC;
this.parent=(void 0);
this.status=h.UNCHANGED;
this.status_explanation=(void 0);
this.new_start_pos=(void 0);
this.new_end_pos=(void 0);
this.corresponding_node=(void 0);
this.unmatched_new_nodes=(void 0);
this.textual_corresponding_node=(void 0);
this.textually_unmatched_new_nodes=(void 0);
this.live_shared_function_infos=(void 0);
}
function BuildCodeInfoTree(aD){
var aE=0;
function BuildNode(){
var aF=aE;
aE++;
var aG=new d();
while(aE<aD.length&&
aD[aE].outer_index==aF){
aG.push(BuildNode());
}
var w=new CodeInfoTreeNode(aD[aF],aG,
aF);
for(var x=0;x<aG.length;x++){
aG[x].parent=w;
}
return w;
}
var aH=BuildNode();
Assert(aE==aD.length);
return aH;
}
function MarkChangedFunctions(aI,am){
var aJ=new function(){
var aK=0;
var aL=0;
this.current=function(){return am[aK];};
this.next=function(){
var ay=am[aK];
aL=ay.pos2+ay.len2-(ay.pos1+ay.len1);
aK++;
};
this.done=function(){return aK>=am.length;};
this.TranslatePos=function(as){return as+aL;};
};
function ProcessInternals(aM){
aM.new_start_pos=aJ.TranslatePos(
aM.info.start_position);
var aN=0;
var aO=false;
var aP=false;
while(!aJ.done()&&
aJ.current().pos1<aM.info.end_position){
if(aN<aM.children.length){
var aQ=aM.children[aN];
if(aQ.info.end_position<=aJ.current().pos1){
ProcessUnchangedChild(aQ);
aN++;
continue;
}else if(aQ.info.start_position>=
aJ.current().pos1+aJ.current().len1){
aO=true;
aJ.next();
continue;
}else if(aQ.info.start_position<=aJ.current().pos1&&
aQ.info.end_position>=aJ.current().pos1+
aJ.current().len1){
ProcessInternals(aQ);
aP=aP||
(aQ.status!=h.UNCHANGED);
aO=aO||
(aQ.status==h.DAMAGED);
aN++;
continue;
}else{
aO=true;
aQ.status=h.DAMAGED;
aQ.status_explanation=
"Text diff overlaps with function boundary";
aN++;
continue;
}
}else{
if(aJ.current().pos1+aJ.current().len1<=
aM.info.end_position){
aM.status=h.CHANGED;
aJ.next();
continue;
}else{
aM.status=h.DAMAGED;
aM.status_explanation=
"Text diff overlaps with function boundary";
return;
}
}
Assert("Unreachable",false);
}
while(aN<aM.children.length){
var aQ=aM.children[aN];
ProcessUnchangedChild(aQ);
aN++;
}
if(aO){
aM.status=h.CHANGED;
}else if(aP){
aM.status=h.SOURCE_CHANGED;
}
aM.new_end_pos=
aJ.TranslatePos(aM.info.end_position);
}
function ProcessUnchangedChild(w){
w.new_start_pos=aJ.TranslatePos(w.info.start_position);
w.new_end_pos=aJ.TranslatePos(w.info.end_position);
}
ProcessInternals(aI);
}
function FindCorrespondingFunctions(aR,aS){
function ProcessNode(v,aT){
var aU=
IsFunctionContextLocalsChanged(v.info,aT.info);
if(aU){
v.status=h.CHANGED;
}
var aV=v.children;
var aW=aT.children;
var aX=[];
var aY=[];
var aZ=0;
var ba=0;
while(aZ<aV.length){
if(aV[aZ].status==h.DAMAGED){
aZ++;
}else if(ba<aW.length){
if(aW[ba].info.start_position<
aV[aZ].new_start_pos){
aX.push(aW[ba]);
aY.push(aW[ba]);
ba++;
}else if(aW[ba].info.start_position==
aV[aZ].new_start_pos){
if(aW[ba].info.end_position==
aV[aZ].new_end_pos){
aV[aZ].corresponding_node=
aW[ba];
aV[aZ].textual_corresponding_node=
aW[ba];
if(aU){
aV[aZ].status=h.DAMAGED;
aV[aZ].status_explanation=
"Enclosing function is now incompatible. "+
aU;
aV[aZ].corresponding_node=(void 0);
}else if(aV[aZ].status!=
h.UNCHANGED){
ProcessNode(aV[aZ],
aW[ba]);
if(aV[aZ].status==h.DAMAGED){
aX.push(
aV[aZ].corresponding_node);
aV[aZ].corresponding_node=(void 0);
v.status=h.CHANGED;
}
}else{
ProcessNode(aV[aZ],aW[ba]);
}
}else{
aV[aZ].status=h.DAMAGED;
aV[aZ].status_explanation=
"No corresponding function in new script found";
v.status=h.CHANGED;
aX.push(aW[ba]);
aY.push(aW[ba]);
}
ba++;
aZ++;
}else{
aV[aZ].status=h.DAMAGED;
aV[aZ].status_explanation=
"No corresponding function in new script found";
v.status=h.CHANGED;
aZ++;
}
}else{
aV[aZ].status=h.DAMAGED;
aV[aZ].status_explanation=
"No corresponding function in new script found";
v.status=h.CHANGED;
aZ++;
}
}
while(ba<aW.length){
aX.push(aW[ba]);
aY.push(aW[ba]);
ba++;
}
if(v.status==h.CHANGED){
if(v.info.param_num!=aT.info.param_num){
v.status=h.DAMAGED;
v.status_explanation="Changed parameter number: "+
v.info.param_num+" and "+aT.info.param_num;
}
}
v.unmatched_new_nodes=aX;
v.textually_unmatched_new_nodes=
aY;
}
ProcessNode(aR,aS);
aR.corresponding_node=aS;
aR.textual_corresponding_node=aS;
Assert(aR.status!=h.DAMAGED,
"Script became damaged");
}
function FindLiveSharedInfos(aR,M){
var bb=%LiveEditFindSharedFunctionInfosForScript(M);
var bc=new d();
for(var x=0;x<bb.length;x++){
bc.push(new SharedInfoWrapper(bb[x]));
}
function FindFunctionInfos(O){
var bd=[];
for(var x=0;x<bc.length;x++){
var be=bc[x];
if(be.start_position==O.start_position&&
be.end_position==O.end_position){
bd.push(be);
}
}
if(bd.length>0){
return bd;
}
}
function TraverseTree(w){
w.live_shared_function_infos=FindFunctionInfos(w.info);
for(var x=0;x<w.children.length;x++){
TraverseTree(w.children[x]);
}
}
TraverseTree(aR);
}
function FunctionCompileInfo(bf){
this.function_name=bf[0];
this.start_position=bf[1];
this.end_position=bf[2];
this.param_num=bf[3];
this.scope_info=bf[4];
this.outer_index=bf[5];
this.shared_function_info=bf[6];
this.function_literal_id=bf[7];
this.next_sibling_index=null;
this.raw_array=bf;
}
function SharedInfoWrapper(bf){
this.function_name=bf[0];
this.start_position=bf[1];
this.end_position=bf[2];
this.info=bf[3];
this.raw_array=bf;
}
function PatchPositions(ad,al,ae){
if(ad.live_shared_function_infos){
ad.live_shared_function_infos.forEach(function(Q){
%LiveEditPatchFunctionPositions(Q.raw_array,
al);
});
ae.push({name:ad.info.function_name});
}else{
ae.push(
{name:ad.info.function_name,info_not_found:true});
}
}
function CreateNameForOldScript(M){
return M.name+" (old)";
}
function IsFunctionContextLocalsChanged(bg,bh){
var bi=bg.scope_info;
var bj=bh.scope_info;
var bk;
var bl;
if(bi){
bk=bi.toString();
}else{
bk="";
}
if(bj){
bl=bj.toString();
}else{
bl="";
}
if(bk!=bl){
return"Variable map changed: ["+bk+
"] => ["+bl+"]";
}
return;
}
var bm;
function CheckStackActivations(old_shared_wrapper_list,
new_shared_list,
Z){
var bn=new d();
for(var x=0;x<old_shared_wrapper_list.length;x++){
bn[x]=old_shared_wrapper_list[x].info;
}
var bo=%LiveEditCheckAndDropActivations(
bn,new_shared_list,true);
if(bo[old_shared_wrapper_list.length]){
throw new Failure(bo[old_shared_wrapper_list.length]);
}
var bp=new d();
var bq=new d();
for(var x=0;x<bn.length;x++){
var br=old_shared_wrapper_list[x];
if(bo[x]==bm.REPLACED_ON_ACTIVE_STACK){
bq.push({name:br.function_name});
}else if(bo[x]!=bm.AVAILABLE_FOR_PATCH){
var bs={
name:br.function_name,
start_pos:br.start_position,
end_pos:br.end_position,
replace_problem:
bm.SymbolName(bo[x])
};
bp.push(bs);
}
}
if(bq.length>0){
Z.push({dropped_from_stack:bq});
}
if(bp.length>0){
Z.push({functions_on_stack:bp});
throw new Failure("Blocked by functions on stack");
}
return bq.length;
}
var bm={
AVAILABLE_FOR_PATCH:1,
BLOCKED_ON_ACTIVE_STACK:2,
BLOCKED_ON_OTHER_STACK:3,
BLOCKED_UNDER_NATIVE_CODE:4,
REPLACED_ON_ACTIVE_STACK:5,
BLOCKED_UNDER_GENERATOR:6,
BLOCKED_ACTIVE_GENERATOR:7,
BLOCKED_NO_NEW_TARGET_ON_RESTART:8
};
bm.SymbolName=function(bt){
var bu=bm;
for(var bv in bu){
if(bu[bv]==bt){
return bv;
}
}
};
function Failure(ag){
this.message=ag;
}
Failure.prototype.toString=function(){
return"LiveEdit Failure: "+this.message;
};
function CopyErrorPositionToDetails(bw,o){
function createPositionStruct(M,bx){
if(bx==-1)return;
var by=M.locationFromPosition(bx,true);
if(by==null)return;
return{
line:by.line+1,
column:by.column+1,
position:bx
};
}
if(!("scriptObject"in bw)||!("startPosition"in bw)){
return;
}
var M=bw.scriptObject;
var bz={
start:createPositionStruct(M,bw.startPosition),
end:createPositionStruct(M,bw.endPosition)
};
o.position=bz;
}
function SetScriptSource(M,bA,bB,Z){
var i=M.source;
var bC=CompareStrings(i,bA);
return ApplyPatchMultiChunk(M,bC,bA,bB,
Z);
}
function CompareStrings(bD,bE){
return %LiveEditCompareStrings(bD,bE);
}
function ApplySingleChunkPatch(M,change_pos,change_len,new_str,
Z){
var i=M.source;
var bA=i.substring(0,change_pos)+
new_str+i.substring(change_pos+change_len);
return ApplyPatchMultiChunk(M,
[change_pos,change_pos+change_len,change_pos+new_str.length],
bA,false,Z);
}
function DescribeChangeTree(aR){
function ProcessOldNode(w){
var bF=[];
for(var x=0;x<w.children.length;x++){
var aQ=w.children[x];
if(aQ.status!=h.UNCHANGED){
bF.push(ProcessOldNode(aQ));
}
}
var bG=[];
if(w.textually_unmatched_new_nodes){
for(var x=0;x<w.textually_unmatched_new_nodes.length;x++){
var aQ=w.textually_unmatched_new_nodes[x];
bG.push(ProcessNewNode(aQ));
}
}
var bH={
name:w.info.function_name,
positions:DescribePositions(w),
status:w.status,
children:bF,
new_children:bG
};
if(w.status_explanation){
bH.status_explanation=w.status_explanation;
}
if(w.textual_corresponding_node){
bH.new_positions=DescribePositions(w.textual_corresponding_node);
}
return bH;
}
function ProcessNewNode(w){
var bF=[];
if(false){
for(var x=0;x<w.children.length;x++){
bF.push(ProcessNewNode(w.children[x]));
}
}
var bH={
name:w.info.function_name,
positions:DescribePositions(w),
children:bF,
};
return bH;
}
function DescribePositions(w){
return{
start_position:w.info.start_position,
end_position:w.info.end_position
};
}
return ProcessOldNode(aR);
}
var bI={};
bI.SetScriptSource=SetScriptSource;
bI.ApplyPatchMultiChunk=ApplyPatchMultiChunk;
bI.Failure=Failure;
bI.TestApi={
PosTranslator:PosTranslator,
CompareStrings:CompareStrings,
ApplySingleChunkPatch:ApplySingleChunkPatch
};
a.Debug.LiveEdit=bI;
})

4 prologueÙ"
(function(a,b,c){
"use strict";
%CheckIsBootstrapping();
var d=(void 0);
var e=%ExportFromRuntime({});
function Export(f){
f(e);
}
function Import(f){
f.next=d;
d=f;
}
function ImportNow(g){
return e[g];
}
function InstallConstants(h,i){
%CheckIsBootstrapping();
%OptimizeObjectForAddingMultipleProperties(h,i.length>>1);
var j=2|4|1;
for(var k=0;k<i.length;k+=2){
var g=i[k];
var l=i[k+1];
%AddNamedProperty(h,g,l,j);
}
%ToFastProperties(h);
}
function SetUpLockedPrototype(
constructor,fields,methods){
%CheckIsBootstrapping();
var m=constructor.prototype;
var n=(methods.length>>1)+(fields?fields.length:0);
if(n>=4){
%OptimizeObjectForAddingMultipleProperties(m,n);
}
if(fields){
for(var k=0;k<fields.length;k++){
%AddNamedProperty(m,fields[k],
(void 0),2|4);
}
}
for(var k=0;k<methods.length;k+=2){
var o=methods[k];
var f=methods[k+1];
%AddNamedProperty(m,o,f,2|4|1);
%SetNativeFlag(f);
}
%InternalSetPrototype(m,null);
%ToFastProperties(m);
}
function PostNatives(b){
%CheckIsBootstrapping();
for(;!(d===(void 0));d=d.next){
d(e);
}
e=(void 0);
b.Export=(void 0);
b.Import=(void 0);
b.ImportNow=(void 0);
b.PostNatives=(void 0);
}
%OptimizeObjectForAddingMultipleProperties(b,14);
b.Import=Import;
b.ImportNow=ImportNow;
b.Export=Export;
b.InstallConstants=InstallConstants;
b.SetUpLockedPrototype=SetUpLockedPrototype;
b.PostNatives=PostNatives;
%ToFastProperties(b);
%OptimizeObjectForAddingMultipleProperties(c,11);
c.logStackTrace=function logStackTrace(){
%DebugTrace();
};
c.log=function log(){
let message='';
for(const arg of arguments){
message+=arg;
}
%GlobalPrint(message);
};
c.createPrivateSymbol=function createPrivateSymbol(g){
return %CreatePrivateSymbol(g);
};
c.simpleBind=function simpleBind(p,q){
return function(...args){
return %reflect_apply(p,q,args);
};
};
c.uncurryThis=function uncurryThis(p){
return function(q,...args){
return %reflect_apply(p,q,args);
};
};
c.rejectPromise=function rejectPromise(r,s){
%promise_internal_reject(r,s,true);
}
c.markPromiseAsHandled=function markPromiseAsHandled(r){
%PromiseMarkAsHandled(r);
};
c.promiseState=function promiseState(r){
return %PromiseStatus(r);
};
c.kPROMISE_PENDING=0;
c.kPROMISE_FULFILLED=1;
c.kPROMISE_REJECTED=2;
%ToFastProperties(c);
})

max-mini
(function(a,b){
"use strict";
%CheckIsBootstrapping();
function MaxSimple(c,d){
return c>d?c:d;
}
function MinSimple(c,d){
return c>d?d:c;
}
%SetForceInlineFlag(MaxSimple);
%SetForceInlineFlag(MinSimple);
b.Export(function(e){
e.MaxSimple=MaxSimple;
e.MinSimple=MinSimple;
});
})

$v8nativesÍ
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d=b.ImportNow("iterator_symbol");
%DefineMethodsInternal(c.prototype,class{
toLocaleString(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Object.prototype.toLocaleString");
return this.toString();
}},-1);
function GetMethod(e,f){
var g=e[f];
if((g==null))return(void 0);
if((typeof(g)==='function'))return g;
throw %make_type_error(15,typeof g);
}
function ObjectConstructor(h){
if(c!=new.target&&!(new.target===(void 0))){
return this;
}
if((h===null)||(h===(void 0)))return{};
return(%_ToObject(h));
}
%SetNativeFlag(c);
%SetCode(c,ObjectConstructor);
function GetIterator(e,i){
if((i===(void 0))){
i=e[d];
}
if(!(typeof(i)==='function')){
throw %make_type_error(73,e);
}
var j=%_Call(i,e);
if(!(%_IsJSReceiver(j))){
throw %make_type_error(68,j);
}
return j;
}
b.Export(function(k){
k.GetIterator=GetIterator;
k.GetMethod=GetMethod;
});
})

array
(function(a,b,c){
"use strict";
%CheckIsBootstrapping();
var d;
var e;
var f=a.Array;
var g=b.InternalArray;
var h=b.InternalPackedArray;
var i;
var j;
var k=a.Object.prototype.hasOwnProperty;
var l=a.Object.prototype.toString;
var m=b.ImportNow("iterator_symbol");
var n=b.ImportNow("unscopables_symbol");
b.Import(function(o){
d=o.GetIterator;
e=o.GetMethod;
i=o.MaxSimple;
j=o.MinSimple;
});
function ArraySpeciesCreate(p,q){
q=((q)+0);
var r=%ArraySpeciesConstructor(p);
return new r(q);
}
function KeySortCompare(s,t){
return s-t;
}
function GetSortedArrayKeys(p,u){
if((typeof(u)==='number')){
var v=u;
var w=new g();
for(var x=0;x<v;++x){
var y=p[x];
if(!(y===(void 0))||x in p){
w.push(x);
}
}
return w;
}
return InnerArraySort(u,u.length,KeySortCompare);
}
function SparseJoinWithSeparatorJS(p,w,q,z,A){
var B=w.length;
var C=new g(B*2);
for(var x=0;x<B;x++){
var D=w[x];
C[x*2]=D;
C[x*2+1]=ConvertToString(z,p[D]);
}
return %SparseJoinWithSeparator(C,q,A);
}
function SparseJoin(p,w,z){
var B=w.length;
var C=new g(B);
for(var x=0;x<B;x++){
C[x]=ConvertToString(z,p[w[x]]);
}
return %StringBuilderConcat(C,B,'');
}
function UseSparseVariant(p,q,E,F){
if(!E||q<1000||%HasComplexElements(p)){
return false;
}
if(!%_IsSmi(q)){
return true;
}
var G=q>>2;
var H=%EstimateNumberOfElements(p);
return(H<G)&&
(F>H*4);
}
function Stack(){
this.length=0;
this.values=new g();
}
Stack.prototype.length=null;
Stack.prototype.values=null;
function StackPush(I,J){
I.values[I.length++]=J;
}
function StackPop(I){
I.values[--I.length]=null
}
function StackHas(I,K){
var q=I.length;
var L=I.values;
for(var x=0;x<q;x++){
if(L[x]===K)return true;
}
return false;
}
var M=new Stack();
function DoJoin(p,q,E,A,z){
if(UseSparseVariant(p,q,E,q)){
%NormalizeElements(p);
var w=GetSortedArrayKeys(p,%GetArrayKeys(p,q));
if(A===''){
if(w.length===0)return'';
return SparseJoin(p,w,z);
}else{
return SparseJoinWithSeparatorJS(
p,w,q,z,A);
}
}
if(q===1){
return ConvertToString(z,p[0]);
}
var C=new g(q);
for(var x=0;x<q;x++){
C[x]=ConvertToString(z,p[x]);
}
if(A===''){
return %StringBuilderConcat(C,q,'');
}else{
return %StringBuilderJoin(C,q,A);
}
}
function Join(p,q,A,z){
if(q===0)return'';
var E=(%_IsArray(p));
if(E){
if(StackHas(M,p))return'';
StackPush(M,p);
}
try{
return DoJoin(p,q,E,A,z);
}finally{
if(E)StackPop(M);
}
}
function ConvertToString(z,N){
if((N==null))return'';
return(%_ToString(z?N.toLocaleString():N));
}
function SparseSlice(p,O,P,Q,R){
var u=%GetArrayKeys(p,O+P);
if((typeof(u)==='number')){
var v=u;
for(var x=O;x<v;++x){
var S=p[x];
if(!(S===(void 0))||x in p){
%CreateDataProperty(R,x-O,S);
}
}
}else{
var q=u.length;
for(var T=0;T<q;++T){
var D=u[T];
if(D>=O){
var S=p[D];
if(!(S===(void 0))||D in p){
%CreateDataProperty(R,D-O,S);
}
}
}
}
}
function SparseMove(p,O,P,Q,U){
if(U===P)return;
var V=new g(
j(Q-P+U,0xffffffff));
var W;
var u=%GetArrayKeys(p,Q);
if((typeof(u)==='number')){
var v=u;
for(var x=0;x<O&&x<v;++x){
var S=p[x];
if(!(S===(void 0))||x in p){
V[x]=S;
}
}
for(var x=O+P;x<v;++x){
var S=p[x];
if(!(S===(void 0))||x in p){
V[x-P+U]=S;
}
}
}else{
var q=u.length;
for(var T=0;T<q;++T){
var D=u[T];
if(D<O){
var S=p[D];
if(!(S===(void 0))||D in p){
V[D]=S;
}
}else if(D>=O+P){
var S=p[D];
if(!(S===(void 0))||D in p){
var X=D-P+U;
V[X]=S;
if(X>0xfffffffe){
W=W||new g();
W.push(X);
}
}
}
}
}
%MoveArrayContents(V,p);
if(!(W===(void 0))){
var q=W.length;
for(var x=0;x<q;++x){
var D=W[x];
p[D]=V[D];
}
}
}
function SimpleSlice(p,O,P,Q,R){
for(var x=0;x<P;x++){
var Y=O+x;
if(Y in p){
var S=p[Y];
%CreateDataProperty(R,x,S);
}
}
}
function SimpleMove(p,O,P,Q,U){
if(U!==P){
if(U>P){
for(var x=Q-P;x>O;x--){
var Z=x+P-1;
var aa=x+U-1;
if(Z in p){
p[aa]=p[Z];
}else{
delete p[aa];
}
}
}else{
for(var x=O;x<Q-P;x++){
var Z=x+P;
var aa=x+U;
if(Z in p){
p[aa]=p[Z];
}else{
delete p[aa];
}
}
for(var x=Q;x>Q-P+U;x--){
delete p[x-1];
}
}
}
}
var ab;
%DefineMethodsInternal(f.prototype,class{toString(){
var p;
var ac;
if((%_IsArray(this))){
ac=this.join;
if(ac===ab){
return Join(this,this.length,',',false);
}
p=this;
}else{
p=(%_ToObject(this));
ac=p.join;
}
if(!(typeof(ac)==='function')){
return %_Call(l,p);
}
return %_Call(ac,p);
}},-1);
function InnerArrayToLocaleString(p,q){
return Join(p,(%_ToLength(q)),',',true);
}
%DefineMethodsInternal(f.prototype,class{toLocaleString(){
var p=(%_ToObject(this));
var ad=p.length;
return InnerArrayToLocaleString(p,ad);
}},-1);
function InnerArrayJoin(A,p,q){
if((A===(void 0))){
A=',';
}else{
A=(%_ToString(A));
}
if(q===1){
var y=p[0];
if((y==null))return'';
return(%_ToString(y));
}
return Join(p,q,A,false);
}
%DefineMethodsInternal(f.prototype,class{join(A){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.join");
var p=(%_ToObject(this));
var q=(%_ToLength(p.length));
return InnerArrayJoin(A,p,q);
}},-1);
function ArrayPopFallback(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.pop");
var p=(%_ToObject(this));
var ae=(%_ToLength(p.length));
if(ae==0){
p.length=ae;
return;
}
ae--;
var J=p[ae];
delete p[ae];
p.length=ae;
return J;
}
function ArrayPushFallback(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.push");
var p=(%_ToObject(this));
var ae=(%_ToLength(p.length));
var af=arguments.length;
if(af>9007199254740991-ae)throw %make_type_error(234,af,ae);
for(var x=0;x<af;x++){
p[x+ae]=arguments[x];
}
var ag=ae+af;
p.length=ag;
return ag;
}
function SparseReverse(p,Q){
var w=GetSortedArrayKeys(p,%GetArrayKeys(p,Q));
var ah=w.length-1;
var ai=0;
while(ai<=ah){
var x=w[ai];
var aj=w[ah];
var ak=Q-aj-1;
var al,am;
if(ak<=x){
am=aj;
while(w[--ah]==aj){}
al=ak;
}
if(ak>=x){
al=x;
while(w[++ai]==x){}
am=Q-x-1;
}
var an=p[al];
if(!(an===(void 0))||al in p){
var ao=p[am];
if(!(ao===(void 0))||am in p){
p[al]=ao;
p[am]=an;
}else{
p[am]=an;
delete p[al];
}
}else{
var ao=p[am];
if(!(ao===(void 0))||am in p){
p[al]=ao;
delete p[am];
}
}
}
}
function PackedArrayReverse(p,Q){
var aj=Q-1;
for(var x=0;x<aj;x++,aj--){
var an=p[x];
var ao=p[aj];
p[x]=ao;
p[aj]=an;
}
return p;
}
function GenericArrayReverse(p,Q){
var aj=Q-1;
for(var x=0;x<aj;x++,aj--){
if(x in p){
var an=p[x];
if(aj in p){
var ao=p[aj];
p[x]=ao;
p[aj]=an;
}else{
p[aj]=an;
delete p[x];
}
}else{
if(aj in p){
var ao=p[aj];
p[x]=ao;
delete p[aj];
}
}
}
return p;
}
%DefineMethodsInternal(f.prototype,class{reverse(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.reverse");
var p=(%_ToObject(this));
var Q=(%_ToLength(p.length));
var ap=(%_IsArray(p));
if(UseSparseVariant(p,Q,ap,Q)){
%NormalizeElements(p);
SparseReverse(p,Q);
return p;
}else if(ap&&%_HasFastPackedElements(p)){
return PackedArrayReverse(p,Q);
}else{
return GenericArrayReverse(p,Q);
}
}},-1);
function ArrayShiftFallback(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.shift");
var p=(%_ToObject(this));
var Q=(%_ToLength(p.length));
if(Q===0){
p.length=0;
return;
}
if(%object_is_sealed(p))throw %make_type_error(13);
var aq=p[0];
if(UseSparseVariant(p,Q,(%_IsArray(p)),Q)){
SparseMove(p,0,1,Q,0);
}else{
SimpleMove(p,0,1,Q,0);
}
p.length=Q-1;
return aq;
}
function ArrayUnshiftFallback(ar){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.unshift");
var p=(%_ToObject(this));
var Q=(%_ToLength(p.length));
var as=arguments.length;
if(Q>0&&UseSparseVariant(p,Q,(%_IsArray(p)),Q)&&
!%object_is_sealed(p)){
SparseMove(p,0,0,Q,as);
}else{
SimpleMove(p,0,0,Q,as);
}
for(var x=0;x<as;x++){
p[x]=arguments[x];
}
var ag=Q+as;
p.length=ag;
return ag;
}
function ArraySliceFallback(at,au){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.slice");
var p=(%_ToObject(this));
var Q=(%_ToLength(p.length));
var O=(%_ToInteger(at));
var av=Q;
if(!(au===(void 0)))av=(%_ToInteger(au));
if(O<0){
O+=Q;
if(O<0)O=0;
}else{
if(O>Q)O=Q;
}
if(av<0){
av+=Q;
if(av<0)av=0;
}else{
if(av>Q)av=Q;
}
var aw=ArraySpeciesCreate(p,i(av-O,0));
if(av<O)return aw;
if(UseSparseVariant(p,Q,(%_IsArray(p)),av-O)){
%NormalizeElements(p);
if((%_IsArray(aw)))%NormalizeElements(aw);
SparseSlice(p,O,av-O,Q,aw);
}else{
SimpleSlice(p,O,av-O,Q,aw);
}
aw.length=av-O;
return aw;
}
function ComputeSpliceStartIndex(O,Q){
if(O<0){
O+=Q;
return O<0?0:O;
}
return O>Q?Q:O;
}
function ComputeSpliceDeleteCount(ax,as,Q,O){
var P=0;
if(as==1)
return Q-O;
P=(%_ToInteger(ax));
if(P<0)
return 0;
if(P>Q-O)
return Q-O;
return P;
}
function ArraySpliceFallback(at,ax){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.splice");
var as=arguments.length;
var p=(%_ToObject(this));
var Q=(%_ToLength(p.length));
var O=ComputeSpliceStartIndex((%_ToInteger(at)),Q);
var P=ComputeSpliceDeleteCount(ax,as,Q,
O);
var R=ArraySpeciesCreate(p,P);
R.length=P;
var ay=as>2?as-2:0;
if(P!=ay&&%object_is_sealed(p)){
throw %make_type_error(13);
}else if(P>0&&%object_is_frozen(p)){
throw %make_type_error(12);
}
var az=P;
if(ay!=P){
az+=Q-O-P;
}
if(UseSparseVariant(p,Q,(%_IsArray(p)),az)){
%NormalizeElements(p);
if((%_IsArray(R)))%NormalizeElements(R);
SparseSlice(p,O,P,Q,R);
SparseMove(p,O,P,Q,ay);
}else{
SimpleSlice(p,O,P,Q,R);
SimpleMove(p,O,P,Q,ay);
}
var x=O;
var aA=2;
var aB=arguments.length;
while(aA<aB){
p[x++]=arguments[aA++];
}
p.length=Q-P+ay;
return R;
}
function InnerArraySort(p,q,aC){
if(!(typeof(aC)==='function')){
aC=function(N,aD){
if(N===aD)return 0;
if(%_IsSmi(N)&&%_IsSmi(aD)){
return %SmiLexicographicCompare(N,aD);
}
N=(%_ToString(N));
aD=(%_ToString(aD));
if(N==aD)return 0;
else return N<aD?-1:1;
};
}
function InsertionSort(s,o,aE){
for(var x=o+1;x<aE;x++){
var aF=s[x];
for(var aj=x-1;aj>=o;aj--){
var aG=s[aj];
var aH=aC(aG,aF);
if(aH>0){
s[aj+1]=aG;
}else{
break;
}
}
s[aj+1]=aF;
}
};
function GetThirdIndex(s,o,aE){
var aI=new g();
var aJ=200+((aE-o)&15);
var aj=0;
o+=1;
aE-=1;
for(var x=o;x<aE;x+=aJ){
aI[aj]=[x,s[x]];
aj++;
}
aI.sort(function(s,t){
return aC(s[1],t[1]);
});
var aK=aI[aI.length>>1][0];
return aK;
}
function QuickSort(s,o,aE){
var aK=0;
while(true){
if(aE-o<=10){
InsertionSort(s,o,aE);
return;
}
if(aE-o>1000){
aK=GetThirdIndex(s,o,aE);
}else{
aK=o+((aE-o)>>1);
}
var aL=s[o];
var aM=s[aE-1];
var aN=s[aK];
var aO=aC(aL,aM);
if(aO>0){
var aG=aL;
aL=aM;
aM=aG;
}
var aP=aC(aL,aN);
if(aP>=0){
var aG=aL;
aL=aN;
aN=aM;
aM=aG;
}else{
var aQ=aC(aM,aN);
if(aQ>0){
var aG=aM;
aM=aN;
aN=aG;
}
}
s[o]=aL;
s[aE-1]=aN;
var aR=aM;
var aS=o+1;
var aT=aE-1;
s[aK]=s[aS];
s[aS]=aR;
partition:for(var x=aS+1;x<aT;x++){
var aF=s[x];
var aH=aC(aF,aR);
if(aH<0){
s[x]=s[aS];
s[aS]=aF;
aS++;
}else if(aH>0){
do{
aT--;
if(aT==x)break partition;
var aU=s[aT];
aH=aC(aU,aR);
}while(aH>0);
s[x]=s[aT];
s[aT]=aF;
if(aH<0){
aF=s[x];
s[x]=s[aS];
s[aS]=aF;
aS++;
}
}
}
if(aE-aT<aS-o){
QuickSort(s,aT,aE);
aE=aS;
}else{
QuickSort(s,o,aS);
o=aT;
}
}
};
function CopyFromPrototype(aV,q){
var aW=0;
for(var aX=%object_get_prototype_of(aV);aX;
aX=%object_get_prototype_of(aX)){
var u=(%_IsJSProxy(aX))?q:%GetArrayKeys(aX,q);
if((typeof(u)==='number')){
var aY=u;
for(var x=0;x<aY;x++){
if(!(%_Call(k,aV,x))&&(%_Call(k,aX,x))){
aV[x]=aX[x];
if(x>=aW){aW=x+1;}
}
}
}else{
for(var x=0;x<u.length;x++){
var Y=u[x];
if(!(%_Call(k,aV,Y))&&(%_Call(k,aX,Y))){
aV[Y]=aX[Y];
if(Y>=aW){aW=Y+1;}
}
}
}
}
return aW;
};
function ShadowPrototypeElements(aV,o,aE){
for(var aX=%object_get_prototype_of(aV);aX;
aX=%object_get_prototype_of(aX)){
var u=(%_IsJSProxy(aX))?aE:%GetArrayKeys(aX,aE);
if((typeof(u)==='number')){
var aY=u;
for(var x=o;x<aY;x++){
if((%_Call(k,aX,x))){
aV[x]=(void 0);
}
}
}else{
for(var x=0;x<u.length;x++){
var Y=u[x];
if(o<=Y&&(%_Call(k,aX,Y))){
aV[Y]=(void 0);
}
}
}
}
};
function SafeRemoveArrayHoles(aV){
var aZ=0;
var ba=q-1;
var bb=0;
while(aZ<ba){
while(aZ<ba&&
!(aV[aZ]===(void 0))){
aZ++;
}
if(!(%_Call(k,aV,aZ))){
bb++;
}
while(aZ<ba&&
(aV[ba]===(void 0))){
if(!(%_Call(k,aV,ba))){
bb++;
}
ba--;
}
if(aZ<ba){
aV[aZ]=aV[ba];
aV[ba]=(void 0);
}
}
if(!(aV[aZ]===(void 0)))aZ++;
var x;
for(x=aZ;x<q-bb;x++){
aV[x]=(void 0);
}
for(x=q-bb;x<q;x++){
if(x in %object_get_prototype_of(aV)){
aV[x]=(void 0);
}else{
delete aV[x];
}
}
return aZ;
};
if(q<2)return p;
var E=(%_IsArray(p));
var bc;
if(!E){
bc=CopyFromPrototype(p,q);
}
var bd=%RemoveArrayHoles(p,q);
if(bd==-1){
bd=SafeRemoveArrayHoles(p);
}
QuickSort(p,0,bd);
if(!E&&(bd+1<bc)){
ShadowPrototypeElements(p,bd,bc);
}
return p;
}
%DefineMethodsInternal(f.prototype,class{sort(aC){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.sort");
var p=(%_ToObject(this));
var q=(%_ToLength(p.length));
return InnerArraySort(p,q,aC);
}},-1);
%DefineMethodsInternal(f.prototype,class{lastIndexOf(aF,Y){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.lastIndexOf");
var p=this;
var q=(%_ToLength(this.length));
if(q==0)return-1;
if(arguments.length<2){
Y=q-1;
}else{
Y=(((%_ToInteger(Y)))+0);
if(Y<0)Y+=q;
if(Y<0)return-1;
else if(Y>=q)Y=q-1;
}
var be=0;
var aW=Y;
if(UseSparseVariant(p,q,(%_IsArray(p)),Y)){
%NormalizeElements(p);
var u=%GetArrayKeys(p,Y+1);
if((typeof(u)==='number')){
aW=u;
}else{
if(u.length==0)return-1;
var bf=GetSortedArrayKeys(p,u);
var x=bf.length-1;
while(x>=0){
var D=bf[x];
if(p[D]===aF)return D;
x--;
}
return-1;
}
}
if(!(aF===(void 0))){
for(var x=aW;x>=be;x--){
if(p[x]===aF)return x;
}
return-1;
}
for(var x=aW;x>=be;x--){
if((p[x]===(void 0))&&x in p){
return x;
}
}
return-1;
}},1);
%DefineMethodsInternal(f.prototype,class{copyWithin(target,at,au){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.copyWithin");
var p=(%_ToObject(this));
var q=(%_ToLength(p.length));
target=(%_ToInteger(target));
var aE;
if(target<0){
aE=i(q+target,0);
}else{
aE=j(target,q);
}
at=(%_ToInteger(at));
var o;
if(at<0){
o=i(q+at,0);
}else{
o=j(at,q);
}
au=(au===(void 0))?q:(%_ToInteger(au));
var bg;
if(au<0){
bg=i(q+au,0);
}else{
bg=j(au,q);
}
var bh=j(bg-o,q-aE);
var bi=1;
if(o<aE&&aE<(o+bh)){
bi=-1;
o=o+bh-1;
aE=aE+bh-1;
}
while(bh>0){
if(o in p){
p[aE]=p[o];
}else{
delete p[aE];
}
o=o+bi;
aE=aE+bi;
bh--;
}
return p;
}},2);
function InnerArrayFind(bj,bk,p,q){
if(!(typeof(bj)==='function')){
throw %make_type_error(15,bj);
}
for(var x=0;x<q;x++){
var aF=p[x];
if(%_Call(bj,bk,aF,x,p)){
return aF;
}
}
return;
}
%DefineMethodsInternal(f.prototype,class{find(bj,bk){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.find");
var p=(%_ToObject(this));
var q=(%_ToInteger(p.length));
return InnerArrayFind(bj,bk,p,q);
}},1);
function InnerArrayFindIndex(bj,bk,p,q){
if(!(typeof(bj)==='function')){
throw %make_type_error(15,bj);
}
for(var x=0;x<q;x++){
var aF=p[x];
if(%_Call(bj,bk,aF,x,p)){
return x;
}
}
return-1;
}
%DefineMethodsInternal(f.prototype,class{findIndex(bj,bk){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.findIndex");
var p=(%_ToObject(this));
var q=(%_ToInteger(p.length));
return InnerArrayFindIndex(bj,bk,p,q);
}},1);
%DefineMethodsInternal(f.prototype,class{fill(J,at,au){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Array.prototype.fill");
var p=(%_ToObject(this));
var q=(%_ToLength(p.length));
var x=(at===(void 0))?0:(%_ToInteger(at));
var au=(au===(void 0))?q:(%_ToInteger(au));
if(x<0){
x+=q;
if(x<0)x=0;
}else{
if(x>q)x=q;
}
if(au<0){
au+=q;
if(au<0)au=0;
}else{
if(au>q)au=q;
}
if((au-x)>0&&%object_is_frozen(p)){
throw %make_type_error(12);
}
for(;x<au;x++)
p[x]=J;
return p;
}},1);
%DefineMethodsInternal(f,class{'from'(arrayLike,mapfn,receiver){
var bl=(%_ToObject(arrayLike));
var bm=!(mapfn===(void 0));
if(bm){
if(!(typeof(mapfn)==='function')){
throw %make_type_error(15,mapfn);
}
}
var bn=e(bl,m);
var T;
var aw;
var bo;
var bp;
if(!(bn===(void 0))){
aw=%IsConstructor(this)?new this():[];
T=0;
for(bp of
{[m](){return d(bl,bn)}}){
if(bm){
bo=%_Call(mapfn,receiver,bp,T);
}else{
bo=bp;
}
%CreateDataProperty(aw,T,bo);
T++;
}
aw.length=T;
return aw;
}else{
var Q=(%_ToLength(bl.length));
aw=%IsConstructor(this)?new this(Q):new f(Q);
for(T=0;T<Q;++T){
bp=bl[T];
if(bm){
bo=%_Call(mapfn,receiver,bp,T);
}else{
bo=bp;
}
%CreateDataProperty(aw,T,bo);
}
aw.length=T;
return aw;
}
}},1);
%DefineMethodsInternal(f,class{of(...args){
var q=args.length;
var r=this;
var p=%IsConstructor(r)?new r(q):[];
for(var x=0;x<q;x++){
%CreateDataProperty(p,x,args[x]);
}
p.length=q;
return p;
}},-1);
var bq={
__proto__:null,
copyWithin:true,
entries:true,
fill:true,
find:true,
findIndex:true,
includes:true,
keys:true,
};
%ToFastProperties(bq);
%AddNamedProperty(f.prototype,n,bq,
2|1);
var br=f.prototype.indexOf;
var ab=f.prototype.join;
var bs=f.prototype.pop;
var bt=f.prototype.push;
var bu=f.prototype.slice;
var bv=f.prototype.shift;
var bw=f.prototype.sort;
var bx=f.prototype.splice;
var by=f.prototype.toString;
var bz=f.prototype.unshift;
var bA=f.prototype.entries;
var bB=f.prototype.forEach;
var bC=f.prototype.keys;
var bD=f.prototype[m];
b.SetUpLockedPrototype(g,f(),[
"indexOf",br,
"join",ab,
"pop",bs,
"push",bt,
"shift",bv,
"sort",bw,
"splice",bx
]);
b.SetUpLockedPrototype(h,f(),[
"join",ab,
"pop",bs,
"push",bt,
"shift",bv
]);
b.SetUpLockedPrototype(c.InternalPackedArray,f(),[
"push",bt,
"pop",bs,
"shift",bv,
"unshift",bz,
"splice",bx,
"slice",bu
]);
b.Export(function(aE){
aE.ArrayJoin=ab;
aE.ArrayPush=bt;
aE.ArrayToString=by;
aE.ArrayValues=bD;
aE.InnerArrayFind=InnerArrayFind;
aE.InnerArrayFindIndex=InnerArrayFindIndex;
aE.InnerArrayJoin=InnerArrayJoin;
aE.InnerArraySort=InnerArraySort;
aE.InnerArrayToLocaleString=InnerArrayToLocaleString;
});
%InstallToContext([
"array_entries_iterator",bA,
"array_for_each_iterator",bB,
"array_keys_iterator",bC,
"array_values_iterator",bD,
"array_pop",ArrayPopFallback,
"array_push",ArrayPushFallback,
"array_shift",ArrayShiftFallback,
"array_splice",ArraySpliceFallback,
"array_slice",ArraySliceFallback,
"array_unshift",ArrayUnshiftFallback,
]);
});

stringJ
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.String;
var d=b.ImportNow("match_symbol");
var e=b.ImportNow("search_symbol");
function HtmlEscape(f){
return %RegExpInternalReplace(/"/g,(%_ToString(f)),"&quot;");
}
%DefineMethodsInternal(c.prototype,class{
match(pattern){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.match");
if(!(pattern==null)){
var g=pattern[d];
if(!(g===(void 0))){
return %_Call(g,pattern,this);
}
}
var h=(%_ToString(this));
var i=%RegExpCreate(pattern);
return i[d](h);
}
search(pattern){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.search");
if(!(pattern==null)){
var j=pattern[e];
if(!(j===(void 0))){
return %_Call(j,pattern,this);
}
}
var h=(%_ToString(this));
var i=%RegExpCreate(pattern);
return %_Call(i[e],i,h);
}
anchor(name){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.anchor");
return"<a name=\""+HtmlEscape(name)+"\">"+(%_ToString(this))+
"</a>";
}
big(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.big");
return"<big>"+(%_ToString(this))+"</big>";
}
blink(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.blink");
return"<blink>"+(%_ToString(this))+"</blink>";
}
bold(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.bold");
return"<b>"+(%_ToString(this))+"</b>";
}
fixed(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.fixed");
return"<tt>"+(%_ToString(this))+"</tt>";
}
fontcolor(color){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.fontcolor");
return"<font color=\""+HtmlEscape(color)+"\">"+(%_ToString(this))+
"</font>";
}
fontsize(size){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.fontsize");
return"<font size=\""+HtmlEscape(size)+"\">"+(%_ToString(this))+
"</font>";
}
italics(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.italics");
return"<i>"+(%_ToString(this))+"</i>";
}
link(s){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.link");
return"<a href=\""+HtmlEscape(s)+"\">"+(%_ToString(this))+"</a>";
}
small(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.small");
return"<small>"+(%_ToString(this))+"</small>";
}
strike(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.strike");
return"<strike>"+(%_ToString(this))+"</strike>";
}
sub(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.sub");
return"<sub>"+(%_ToString(this))+"</sub>";
}
sup(){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.sup");
return"<sup>"+(%_ToString(this))+"</sup>";
}
repeat(count){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.repeat");
var k=(%_ToString(this));
var l=(%_ToInteger(count));
if(l<0||l===(1/0))throw %make_range_error(161);
if(k.length===0)return"";
if(l>%_MaxSmi())throw %make_range_error(170);
var m="";
while(true){
if(l&1)m+=k;
l>>=1;
if(l===0)return m;
k+=k;
}
}
codePointAt(pos){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.codePointAt");
var n=(%_ToString(this));
var o=n.length;
pos=(%_ToInteger(pos));
if(pos<0||pos>=o){
return(void 0);
}
var p=%_StringCharCodeAt(n,pos);
if(p<0xD800||p>0xDBFF||pos+1==o){
return p;
}
var q=%_StringCharCodeAt(n,pos+1);
if(q<0xDC00||q>0xDFFF){
return p;
}
return(p-0xD800)*0x400+q+0x2400;
}
},-1);
function StringPad(r,s,t){
s=(%_ToLength(s));
var u=r.length;
if(s<=u)return"";
if((t===(void 0))){
t=" ";
}else{
t=(%_ToString(t));
if(t===""){
return"";
}
}
var v=s-u;
var w=(v/t.length)|0;
var x=(v-t.length*w)|0;
var y="";
while(true){
if(w&1)y+=t;
w>>=1;
if(w===0)break;
t+=t;
}
if(x){
y+=%_SubString(t,0,x);
}
return y;
}
%DefineMethodsInternal(c.prototype,class{
padStart(s,t){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.padStart");
var r=(%_ToString(this));
return StringPad(r,s,t)+r;
}
padEnd(s,t){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.padEnd");
var r=(%_ToString(this));
return r+StringPad(r,s,t);
}
},1);
%DefineMethodsInternal(c,class{
raw(callSite){
var z=arguments.length;
var A=(%_ToObject(callSite));
var B=(%_ToObject(A.raw));
var C=(%_ToLength(B.length));
if(C<=0)return"";
var D=(%_ToString(B[0]));
for(var E=1;E<C;++E){
if(E<z){
D+=(%_ToString(arguments[E]));
}
D+=(%_ToString(B[E]));
}
return D;
}},-1);
})

(typedarray
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=b.ImportNow("ArrayToString");
var d;
var e;
var f=a.Array;
var g=a.ArrayBuffer;
var h=g.prototype;
var i=a.Object;
var j;
var k;
var l;
var m;
var n;
var o=b.InternalArray;
var p;
var q;
var r=b.ImportNow("iterator_symbol");
var s=b.ImportNow("species_symbol");
var t=b.ImportNow("to_string_tag_symbol");
var u=a.Uint8Array;

var v=a.Int8Array;

var w=a.Uint16Array;

var x=a.Int16Array;

var y=a.Uint32Array;

var z=a.Int32Array;

var A=a.Float32Array;

var B=a.Float64Array;

var C=a.Uint8ClampedArray;


var D=%object_get_prototype_of(u);
b.Import(function(E){
d=E.GetIterator;
e=E.GetMethod;
j=E.InnerArrayFind;
k=E.InnerArrayFindIndex;
l=E.InnerArrayJoin;
m=E.InnerArraySort;
n=E.InnerArrayToLocaleString;
p=E.MaxSimple;
q=E.MinSimple;
});
function SpeciesConstructor(F,G){
var H=F.constructor;
if((H===(void 0))){
return G;
}
if(!(%_IsJSReceiver(H))){
throw %make_type_error(30);
}
var I=H[s];
if((I==null)){
return G;
}
if(%IsConstructor(I)){
return I;
}
throw %make_type_error(246);
}
function ValidateTypedArray(J,K){
if(!(%_IsTypedArray(J)))throw %make_type_error(76);
if(%_ArrayBufferViewWasNeutered(J))
throw %make_type_error(39,K);
}
function TypedArrayDefaultConstructor(L){
switch(%_ClassOf(L)){
case"Uint8Array":
return u;

case"Int8Array":
return v;

case"Uint16Array":
return w;

case"Int16Array":
return x;

case"Uint32Array":
return y;

case"Int32Array":
return z;

case"Float32Array":
return A;

case"Float64Array":
return B;

case"Uint8ClampedArray":
return C;


}
throw %make_type_error(48,
"TypedArrayDefaultConstructor",this);
}
function TypedArrayCreate(H,M,N,O){
if((N===(void 0))){
var P=new H(M);
}else{
var P=new H(M,N,O);
}
ValidateTypedArray(P,"TypedArrayCreate");
if((typeof(M)==='number')&&%_TypedArrayGetLength(P)<M){
throw %make_type_error(262);
}
return P;
}
function TypedArraySpeciesCreate(Q,M,N,O){
var G=TypedArrayDefaultConstructor(Q);
var H=SpeciesConstructor(Q,G);
return TypedArrayCreate(H,M,N,O);
}
function Uint8ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,1);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,1);
}
}
function Uint8ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*1;
%typed_array_construct_by_array_like(R,L,Z,1);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Uint8ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,1);
}else if((%_IsTypedArray(N))){
Uint8ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,1);
}else{
Uint8ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,1);
}
}else{
throw %make_type_error(29,"Uint8Array")
}
}
function Uint8ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*1;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Int8ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,1);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,1);
}
}
function Int8ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*1;
%typed_array_construct_by_array_like(R,L,Z,1);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Int8ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,1);
}else if((%_IsTypedArray(N))){
Int8ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,1);
}else{
Int8ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,1);
}
}else{
throw %make_type_error(29,"Int8Array")
}
}
function Int8ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*1;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Uint16ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,2);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,2);
}
}
function Uint16ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*2;
%typed_array_construct_by_array_like(R,L,Z,2);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Uint16ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,2);
}else if((%_IsTypedArray(N))){
Uint16ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,2);
}else{
Uint16ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,2);
}
}else{
throw %make_type_error(29,"Uint16Array")
}
}
function Uint16ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*2;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Int16ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,2);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,2);
}
}
function Int16ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*2;
%typed_array_construct_by_array_like(R,L,Z,2);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Int16ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,2);
}else if((%_IsTypedArray(N))){
Int16ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,2);
}else{
Int16ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,2);
}
}else{
throw %make_type_error(29,"Int16Array")
}
}
function Int16ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*2;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Uint32ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,4);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,4);
}
}
function Uint32ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*4;
%typed_array_construct_by_array_like(R,L,Z,4);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Uint32ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,4);
}else if((%_IsTypedArray(N))){
Uint32ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,4);
}else{
Uint32ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,4);
}
}else{
throw %make_type_error(29,"Uint32Array")
}
}
function Uint32ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*4;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Int32ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,4);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,4);
}
}
function Int32ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*4;
%typed_array_construct_by_array_like(R,L,Z,4);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Int32ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,4);
}else if((%_IsTypedArray(N))){
Int32ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,4);
}else{
Int32ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,4);
}
}else{
throw %make_type_error(29,"Int32Array")
}
}
function Int32ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*4;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Float32ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,4);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,4);
}
}
function Float32ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*4;
%typed_array_construct_by_array_like(R,L,Z,4);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Float32ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,4);
}else if((%_IsTypedArray(N))){
Float32ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,4);
}else{
Float32ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,4);
}
}else{
throw %make_type_error(29,"Float32Array")
}
}
function Float32ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*4;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Float64ArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,8);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,8);
}
}
function Float64ArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*8;
%typed_array_construct_by_array_like(R,L,Z,8);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Float64ArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,8);
}else if((%_IsTypedArray(N))){
Float64ArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,8);
}else{
Float64ArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,8);
}
}else{
throw %make_type_error(29,"Float64Array")
}
}
function Float64ArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*8;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}

function Uint8ClampedArrayConstructByIterable(R,S,T){
if(%IterableToListCanBeElided(S)){
%typed_array_construct_by_array_like(
R,S,S.length,1);
}else{
var U=new o();
var V=%_Call(T,S);
var W={
__proto__:null
};
W[r]=function(){return V;}
for(var X of W){
U.push(X);
}
%typed_array_construct_by_array_like(R,U,U.length,1);
}
}
function Uint8ClampedArrayConstructByTypedArray(R,L){
var Y=%TypedArrayGetBuffer(L);
var Z=%_TypedArrayGetLength(L);
var aa=%_ArrayBufferViewGetByteLength(L);
var ab=Z*1;
%typed_array_construct_by_array_like(R,L,Z,1);
var ac=(%_ClassOf(Y)==='SharedArrayBuffer')
?g
:SpeciesConstructor(Y,g);
var ad=ac.prototype;
if((%_IsJSReceiver(ad))&&ad!==h){
%InternalSetPrototype(%TypedArrayGetBuffer(R),ad);
}
}
function Uint8ClampedArrayConstructor(N,O,ae){
if(!(new.target===(void 0))){
if((%_ClassOf(N)==='ArrayBuffer')||(%_ClassOf(N)==='SharedArrayBuffer')){
%typed_array_construct_by_array_buffer(
this,N,O,ae,1);
}else if((%_IsTypedArray(N))){
Uint8ClampedArrayConstructByTypedArray(this,N);
}else if((%_IsJSReceiver(N))){
var T=N[r];
if((T===(void 0))){
%typed_array_construct_by_array_like(
this,N,N.length,1);
}else{
Uint8ClampedArrayConstructByIterable(this,N,T);
}
}else{
%typed_array_construct_by_length(this,N,1);
}
}else{
throw %make_type_error(29,"Uint8ClampedArray")
}
}
function Uint8ClampedArraySubArray(af,ag){
var ah=(%_ToInteger(af));
if(!(ag===(void 0))){
var ai=(%_ToInteger(ag));
var aj=%_TypedArrayGetLength(this);
}else{
var aj=%_TypedArrayGetLength(this);
var ai=aj;
}
if(ah<0){
ah=p(0,aj+ah);
}else{
ah=q(ah,aj);
}
if(ai<0){
ai=p(0,aj+ai);
}else{
ai=q(ai,aj);
}
if(ai<ah){
ai=ah;
}
var ak=ai-ah;
var al=
%_ArrayBufferViewGetByteOffset(this)+ah*1;
return TypedArraySpeciesCreate(this,%TypedArrayGetBuffer(this),
al,ak);
}


%DefineMethodsInternal(D.prototype,class{subarray(af,ag){
switch(%_ClassOf(this)){
case"Uint8Array":
return %_Call(Uint8ArraySubArray,this,af,ag);

case"Int8Array":
return %_Call(Int8ArraySubArray,this,af,ag);

case"Uint16Array":
return %_Call(Uint16ArraySubArray,this,af,ag);

case"Int16Array":
return %_Call(Int16ArraySubArray,this,af,ag);

case"Uint32Array":
return %_Call(Uint32ArraySubArray,this,af,ag);

case"Int32Array":
return %_Call(Int32ArraySubArray,this,af,ag);

case"Float32Array":
return %_Call(Float32ArraySubArray,this,af,ag);

case"Float64Array":
return %_Call(Float64ArraySubArray,this,af,ag);

case"Uint8ClampedArray":
return %_Call(Uint8ClampedArraySubArray,this,af,ag);


}
throw %make_type_error(48,
"get %TypedArray%.prototype.subarray",this);
}},-1);
%SetForceInlineFlag(D.prototype.subarray);
function TypedArraySetFromArrayLike(am,an,ao,ap){
if(ap>0){
for(var aq=0;aq<ao;aq++){
am[ap+aq]=an[aq];
}
}
else{
for(var aq=0;aq<ao;aq++){
am[aq]=an[aq];
}
}
}
function TypedArraySetFromOverlappingTypedArray(am,an,ap){
var ar=an.BYTES_PER_ELEMENT;
var as=am.BYTES_PER_ELEMENT;
var ao=%_TypedArrayGetLength(an);
function CopyLeftPart(){
var at=%_ArrayBufferViewGetByteOffset(am)+
(ap+1)*as;
var au=%_ArrayBufferViewGetByteOffset(an);
for(var av=0;
av<ao&&at<=au;
av++){
am[ap+av]=an[av];
at+=as;
au+=ar;
}
return av;
}
var av=CopyLeftPart();
function CopyRightPart(){
var at=%_ArrayBufferViewGetByteOffset(am)+
(ap+ao-1)*as;
var au=%_ArrayBufferViewGetByteOffset(an)+
ao*ar;
for(var aw=ao-1;
aw>=av&&at>=au;
aw--){
am[ap+aw]=an[aw];
at-=as;
au-=ar;
}
return aw;
}
var aw=CopyRightPart();
var ax=new f(aw+1-av);
for(var aq=av;aq<=aw;aq++){
ax[aq-av]=an[aq];
}
for(aq=av;aq<=aw;aq++){
am[ap+aq]=ax[aq-av];
}
}
%DefineMethodsInternal(D.prototype,class{set(R,ap){
var ay=(ap===(void 0))?0:(%_ToInteger(ap));
if(ay<0)throw %make_type_error(183);
if(ay>%_MaxSmi()){
throw %make_range_error(184);
}
switch(%TypedArraySetFastCases(this,R,ay)){
case 0:
return;
case 1:
TypedArraySetFromOverlappingTypedArray(this,R,ay);
return;
case 2:
if(ay===0){
%TypedArrayCopyElements(this,R,%_TypedArrayGetLength(R));
}else{
TypedArraySetFromArrayLike(
this,R,%_TypedArrayGetLength(R),ay);
}
return;
case 3:
var az=R.length;
if((az===(void 0))){
if((typeof(R)==='number')){
throw %make_type_error(50);
}
return;
}
az=(%_ToLength(az));
if(ay+az>%_TypedArrayGetLength(this)){
throw %make_range_error(184);
}
TypedArraySetFromArrayLike(this,R,az,ay);
return;
}
}},1);
%DefineMethodsInternal(D.prototype,class{get[t](){
if(!(%_IsTypedArray(this)))return;
var aA=%_ClassOf(this);
if((aA===(void 0)))return;
return aA;
}},-1);
function InnerTypedArrayFilter(aB,aC,J,Z,aD){
var aE=0;
for(var aq=0;aq<Z;aq++){
if(aq in J){
var aF=J[aq];
if(%_Call(aB,aC,aF,aq,J)){
%CreateDataProperty(aD,aE,aF);
aE++;
}
}
}
return aD;
}
%DefineMethodsInternal(D.prototype,class{filter(aB,thisArg){
ValidateTypedArray(this,"%TypeArray%.prototype.filter");
var Z=%_TypedArrayGetLength(this);
if(!(typeof(aB)==='function'))throw %make_type_error(15,aB);
var aD=new o();
InnerTypedArrayFilter(aB,thisArg,this,Z,aD);
var aG=aD.length;
var aH=TypedArraySpeciesCreate(this,aG);
for(var aq=0;aq<aG;aq++){
aH[aq]=aD[aq];
}
return aH;
}},1);
%DefineMethodsInternal(D.prototype,class{find(predicate,thisArg){
ValidateTypedArray(this,"%TypedArray%.prototype.find");
var Z=%_TypedArrayGetLength(this);
return j(predicate,thisArg,this,Z);
}},1);
%DefineMethodsInternal(D.prototype,class{findIndex(predicate,thisArg){
ValidateTypedArray(this,"%TypedArray%.prototype.findIndex");
var Z=%_TypedArrayGetLength(this);
return k(predicate,thisArg,this,Z);
}},1);
%DefineMethodsInternal(D.prototype,class{sort(comparefn){
ValidateTypedArray(this,"%TypedArray%.prototype.sort");
var Z=%_TypedArrayGetLength(this);
if((comparefn===(void 0))){
return %TypedArraySortFast(this);
}
return m(this,Z,comparefn);
}},-1);
%DefineMethodsInternal(D.prototype,class{toLocaleString(){
ValidateTypedArray(this,"%TypedArray%.prototype.toLocaleString");
var Z=%_TypedArrayGetLength(this);
return n(this,Z);
}},-1);
%DefineMethodsInternal(D.prototype,class{join(separator){
ValidateTypedArray(this,"%TypedArray%.prototype.join");
var Z=%_TypedArrayGetLength(this);
return l(separator,this,Z);
}},-1);
%DefineMethodsInternal(D,class{of(){
var Z=arguments.length;
var J=TypedArrayCreate(this,Z);
for(var aq=0;aq<Z;aq++){
J[aq]=arguments[aq];
}
return J;
}},-1);
function IterableToArrayLike(aI){
var S=e(aI,r);
if(!(S===(void 0))){
var aJ=new o();
var aq=0;
for(var X of
{[r](){return d(aI,S)}}){
aJ[aq]=X;
aq++;
}
var J=[];
%MoveArrayContents(aJ,J);
return J;
}
return(%_ToObject(aI));
}
%DefineMethodsInternal(D,class{'from'(an,mapfn,thisArg){
if(!%IsConstructor(this))throw %make_type_error(70,this);
var aK;
if(!(mapfn===(void 0))){
if(!(typeof(mapfn)==='function'))throw %make_type_error(15,this);
aK=true;
}else{
aK=false;
}
var aL=IterableToArrayLike(an);
var Z=(%_ToLength(aL.length));
var aM=TypedArrayCreate(this,Z);
var X,aN;
for(var aq=0;aq<Z;aq++){
X=aL[aq];
if(aK){
aN=%_Call(mapfn,thisArg,X,aq);
}else{
aN=X;
}
aM[aq]=aN;
}
return aM;
}},1);
function TypedArrayConstructor(){
throw %make_type_error(26,"TypedArray");
}
%SetCode(D,TypedArrayConstructor);
%AddNamedProperty(D.prototype,"toString",c,
2);
%SetCode(u,Uint8ArrayConstructor);
%FunctionSetPrototype(u,new i());
%InternalSetPrototype(u,D);
%InternalSetPrototype(u.prototype,D.prototype);
%AddNamedProperty(u,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(u.prototype,
"constructor",a.Uint8Array,2);
%AddNamedProperty(u.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);

%SetCode(v,Int8ArrayConstructor);
%FunctionSetPrototype(v,new i());
%InternalSetPrototype(v,D);
%InternalSetPrototype(v.prototype,D.prototype);
%AddNamedProperty(v,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(v.prototype,
"constructor",a.Int8Array,2);
%AddNamedProperty(v.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);

%SetCode(w,Uint16ArrayConstructor);
%FunctionSetPrototype(w,new i());
%InternalSetPrototype(w,D);
%InternalSetPrototype(w.prototype,D.prototype);
%AddNamedProperty(w,"BYTES_PER_ELEMENT",2,
1|2|4);
%AddNamedProperty(w.prototype,
"constructor",a.Uint16Array,2);
%AddNamedProperty(w.prototype,
"BYTES_PER_ELEMENT",2,
1|2|4);

%SetCode(x,Int16ArrayConstructor);
%FunctionSetPrototype(x,new i());
%InternalSetPrototype(x,D);
%InternalSetPrototype(x.prototype,D.prototype);
%AddNamedProperty(x,"BYTES_PER_ELEMENT",2,
1|2|4);
%AddNamedProperty(x.prototype,
"constructor",a.Int16Array,2);
%AddNamedProperty(x.prototype,
"BYTES_PER_ELEMENT",2,
1|2|4);

%SetCode(y,Uint32ArrayConstructor);
%FunctionSetPrototype(y,new i());
%InternalSetPrototype(y,D);
%InternalSetPrototype(y.prototype,D.prototype);
%AddNamedProperty(y,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(y.prototype,
"constructor",a.Uint32Array,2);
%AddNamedProperty(y.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);

%SetCode(z,Int32ArrayConstructor);
%FunctionSetPrototype(z,new i());
%InternalSetPrototype(z,D);
%InternalSetPrototype(z.prototype,D.prototype);
%AddNamedProperty(z,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(z.prototype,
"constructor",a.Int32Array,2);
%AddNamedProperty(z.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);

%SetCode(A,Float32ArrayConstructor);
%FunctionSetPrototype(A,new i());
%InternalSetPrototype(A,D);
%InternalSetPrototype(A.prototype,D.prototype);
%AddNamedProperty(A,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(A.prototype,
"constructor",a.Float32Array,2);
%AddNamedProperty(A.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);

%SetCode(B,Float64ArrayConstructor);
%FunctionSetPrototype(B,new i());
%InternalSetPrototype(B,D);
%InternalSetPrototype(B.prototype,D.prototype);
%AddNamedProperty(B,"BYTES_PER_ELEMENT",8,
1|2|4);
%AddNamedProperty(B.prototype,
"constructor",a.Float64Array,2);
%AddNamedProperty(B.prototype,
"BYTES_PER_ELEMENT",8,
1|2|4);

%SetCode(C,Uint8ClampedArrayConstructor);
%FunctionSetPrototype(C,new i());
%InternalSetPrototype(C,D);
%InternalSetPrototype(C.prototype,D.prototype);
%AddNamedProperty(C,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(C.prototype,
"constructor",a.Uint8ClampedArray,2);
%AddNamedProperty(C.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);


})

(collectionK
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Map;
var d=a.Object;
var e=a.Set;
var f=b.ImportNow("hash_code_symbol");
var g=a.Math.random;
var h;
var i;
b.Import(function(j){
h=j.MapIterator;
i=j.SetIterator;
});
function HashToEntry(k,l,m){
var n=(l&((m)-1));
return((%_FixedArrayGet(k,(3+(n))|0)));
}
%SetForceInlineFlag(HashToEntry);
function SetFindEntry(k,m,o,l){
var p=HashToEntry(k,l,m);
if(p===-1)return p;
var q=((%_FixedArrayGet(k,((3+(m)+((p)<<1)))|0)));
if(o===q)return p;
var r=(%IS_VAR(o)!==o);
while(true){
if(r&&(%IS_VAR(q)!==q)){
return p;
}
p=((%_FixedArrayGet(k,((3+(m)+((p)<<1))+1)|0)));
if(p===-1)return p;
q=((%_FixedArrayGet(k,((3+(m)+((p)<<1)))|0)));
if(o===q)return p;
}
return-1;
}
%SetForceInlineFlag(SetFindEntry);
function MapFindEntry(k,m,o,l){
var p=HashToEntry(k,l,m);
if(p===-1)return p;
var q=((%_FixedArrayGet(k,((3+(m)+((p)*3)))|0)));
if(o===q)return p;
var r=(%IS_VAR(o)!==o);
while(true){
if(r&&(%IS_VAR(q)!==q)){
return p;
}
p=((%_FixedArrayGet(k,((3+(m)+((p)*3))+2)|0)));
if(p===-1)return p;
q=((%_FixedArrayGet(k,((3+(m)+((p)*3)))|0)));
if(o===q)return p;
}
return-1;
}
%SetForceInlineFlag(MapFindEntry);
function ComputeIntegerHash(o,s){
var l=o;
l=l^s;
l=~l+(l<<15);
l=l^(l>>>12);
l=l+(l<<2);
l=l^(l>>>4);
l=(l*2057)|0;
l=l^(l>>>16);
return l&0x3fffffff;
}
%SetForceInlineFlag(ComputeIntegerHash);
function GetExistingHash(o){
if(%_IsSmi(o)){
return ComputeIntegerHash(o,0);
}
if((typeof(o)==='string')){
var t=%_StringGetRawHashField(o);
if((t&1)===0){
return t>>>2;
}
}else if((%_IsJSReceiver(o))&&!(%_IsJSProxy(o))&&!(%_ClassOf(o)==='global')){
var l=(o[f]);
return l;
}
return %GenericHash(o);
}
%SetForceInlineFlag(GetExistingHash);
function GetHash(o){
var l=GetExistingHash(o);
if((l===(void 0))){
l=(g()*0x40000000)|0;
if(l===0)l=1;
(o[f]=l);
}
return l;
}
%SetForceInlineFlag(GetHash);
%DefineMethodsInternal(e.prototype,class{
add(o){
if(!(%_IsJSSet(this))){
throw %make_type_error(48,'Set.prototype.add',this);
}
if(o===0){
o=0;
}
var k=%_JSCollectionGetTable(this);
var m=((%_FixedArrayGet(k,(2)|0)));
var l=GetHash(o);
if(SetFindEntry(k,m,o,l)!==-1)return this;
var u=((%_FixedArrayGet(k,(0)|0)));
var v=((%_FixedArrayGet(k,(1)|0)));
var w=m<<1;
if((u+v)>=w){
%SetGrow(this);
k=%_JSCollectionGetTable(this);
m=((%_FixedArrayGet(k,(2)|0)));
u=((%_FixedArrayGet(k,(0)|0)));
v=((%_FixedArrayGet(k,(1)|0)));
}
var p=u+v;
var x=(3+(m)+((p)<<1));
var n=(l&((m)-1));
var y=((%_FixedArrayGet(k,(3+(n))|0)));
((%_FixedArraySet(k,(3+(n))|0,p)));
(((%_FixedArraySet(k,(0)|0,(u+1)|0))));
(%_FixedArraySet(k,(x)|0,o));
((%_FixedArraySet(k,(x+1)|0,(y)|0)));
return this;
}
delete(o){
if(!(%_IsJSSet(this))){
throw %make_type_error(48,
'Set.prototype.delete',this);
}
var k=%_JSCollectionGetTable(this);
var m=((%_FixedArrayGet(k,(2)|0)));
var l=GetExistingHash(o);
if((l===(void 0)))return false;
var p=SetFindEntry(k,m,o,l);
if(p===-1)return false;
var u=((%_FixedArrayGet(k,(0)|0)))-1;
var v=((%_FixedArrayGet(k,(1)|0)))+1;
var x=(3+(m)+((p)<<1));
(%_FixedArraySet(k,(x)|0,%_TheHole()));
(((%_FixedArraySet(k,(0)|0,(u)|0))));
(((%_FixedArraySet(k,(1)|0,(v)|0))));
if(u<(m>>>1))%SetShrink(this);
return true;
}
},-1);
%DefineMethodsInternal(c.prototype,class{
set(o,value){
if(!(%_IsJSMap(this))){
throw %make_type_error(48,
'Map.prototype.set',this);
}
if(o===0){
o=0;
}
var k=%_JSCollectionGetTable(this);
var m=((%_FixedArrayGet(k,(2)|0)));
var l=GetHash(o);
var p=MapFindEntry(k,m,o,l);
if(p!==-1){
var z=(3+(m)+((p)*3));
(%_FixedArraySet(k,(z+1)|0,value));
return this;
}
var u=((%_FixedArrayGet(k,(0)|0)));
var v=((%_FixedArrayGet(k,(1)|0)));
var w=m<<1;
if((u+v)>=w){
%MapGrow(this);
k=%_JSCollectionGetTable(this);
m=((%_FixedArrayGet(k,(2)|0)));
u=((%_FixedArrayGet(k,(0)|0)));
v=((%_FixedArrayGet(k,(1)|0)));
}
p=u+v;
var x=(3+(m)+((p)*3));
var n=(l&((m)-1));
var y=((%_FixedArrayGet(k,(3+(n))|0)));
((%_FixedArraySet(k,(3+(n))|0,p)));
(((%_FixedArraySet(k,(0)|0,(u+1)|0))));
(%_FixedArraySet(k,(x)|0,o));
(%_FixedArraySet(k,(x+1)|0,value));
(%_FixedArraySet(k,(x+2)|0,y));
return this;
}
delete(o){
if(!(%_IsJSMap(this))){
throw %make_type_error(48,
'Map.prototype.delete',this);
}
var k=%_JSCollectionGetTable(this);
var m=((%_FixedArrayGet(k,(2)|0)));
var l=GetHash(o);
var p=MapFindEntry(k,m,o,l);
if(p===-1)return false;
var u=((%_FixedArrayGet(k,(0)|0)))-1;
var v=((%_FixedArrayGet(k,(1)|0)))+1;
var x=(3+(m)+((p)*3));
(%_FixedArraySet(k,(x)|0,%_TheHole()));
(%_FixedArraySet(k,(x+1)|0,%_TheHole()));
(((%_FixedArraySet(k,(0)|0,(u)|0))));
(((%_FixedArraySet(k,(1)|0,(v)|0))));
if(u<(m>>>1))%MapShrink(this);
return true;
}
},-1);
%InstallToContext([
"map_set",c.prototype.set,
"map_delete",c.prototype.delete,
"set_add",e.prototype.add,
"set_delete",e.prototype.delete,
]);
b.Export(function(A){
A.GetExistingHash=GetExistingHash;
A.GetHash=GetHash;
});
})

<weak-collectionM
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c;
var d;
var e=a.WeakMap;
var f=a.WeakSet;
b.Import(function(g){
c=g.GetExistingHash;
d=g.GetHash;
});
function WeakMapConstructor(h){
if((new.target===(void 0))){
throw %make_type_error(29,"WeakMap");
}
%WeakCollectionInitialize(this);
if(!(h==null)){
var i=this.set;
if(!(typeof(i)==='function')){
throw %make_type_error(91,i,'set',this);
}
for(var j of h){
if(!(%_IsJSReceiver(j))){
throw %make_type_error(54,j);
}
%_Call(i,this,j[0],j[1]);
}
}
}
%DefineMethodsInternal(e.prototype,class{
set(key,value){
if(!(%_IsJSWeakMap(this))){
throw %make_type_error(48,
'WeakMap.prototype.set',this);
}
if(!(%_IsJSReceiver(key)))throw %make_type_error(168);
return %WeakCollectionSet(this,key,value,d(key));
}
delete(key){
if(!(%_IsJSWeakMap(this))){
throw %make_type_error(48,
'WeakMap.prototype.delete',this);
}
if(!(%_IsJSReceiver(key)))return false;
var k=c(key);
if((k===(void 0)))return false;
return %WeakCollectionDelete(this,key,k);
}
},-1);
%SetCode(e,WeakMapConstructor);
%FunctionSetLength(e,0);
function WeakSetConstructor(h){
if((new.target===(void 0))){
throw %make_type_error(29,"WeakSet");
}
%WeakCollectionInitialize(this);
if(!(h==null)){
var i=this.add;
if(!(typeof(i)==='function')){
throw %make_type_error(91,i,'add',this);
}
for(var l of h){
%_Call(i,this,l);
}
}
}
%DefineMethodsInternal(f.prototype,class{
add(l){
if(!(%_IsJSWeakSet(this))){
throw %make_type_error(48,
'WeakSet.prototype.add',this);
}
if(!(%_IsJSReceiver(l)))throw %make_type_error(169);
return %WeakCollectionSet(this,l,true,d(l));
}
delete(l){
if(!(%_IsJSWeakSet(this))){
throw %make_type_error(48,
'WeakSet.prototype.delete',this);
}
if(!(%_IsJSReceiver(l)))return false;
var k=c(l);
if((k===(void 0)))return false;
return %WeakCollectionDelete(this,l,k);
}
},-1);
%SetCode(f,WeakSetConstructor);
%FunctionSetLength(f,0);
})

 messages}
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=b.ImportNow("Script");
function ScriptLocationFromPosition(position,
include_resource_offset){
return %ScriptPositionInfo(this,position,!!include_resource_offset);
}
function ScriptNameOrSourceURL(){
if(this.source_url)return this.source_url;
return this.name;
}
b.SetUpLockedPrototype(c,[
"source",
"name",
"source_url",
"source_mapping_url",
"line_offset",
"column_offset"
],[
"locationFromPosition",ScriptLocationFromPosition,
"nameOrSourceURL",ScriptNameOrSourceURL,
]
);
});

$templates
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Map;
var d=b.InternalArray;
var e=new c;
var f=c.prototype.get;
var g=c.prototype.set;
function SameCallSiteElements(h,i){
var j=h.length;
var i=i.raw;
if(j!==i.length)return false;
for(var k=0;k<j;++k){
if(h[k]!==i[k])return false;
}
return true;
}
function GetCachedCallSite(l,m){
var n=%_Call(f,e,m);
if((n===(void 0)))return;
var j=n.length;
for(var k=0;k<j;++k){
if(SameCallSiteElements(l,n[k]))return n[k];
}
}
function SetCachedCallSite(l,m){
var n=%_Call(f,e,m);
var o;
if((n===(void 0))){
o=new d(1);
o[0]=l;
%_Call(g,e,m,o);
}else{
n.push(l);
}
return l;
}
function GetTemplateCallSite(l,h,m){
var p=GetCachedCallSite(h,m);
if(!(p===(void 0)))return p;
%AddNamedProperty(l,"raw",%object_freeze(h),
1|2|4);
return SetCachedCallSite(%object_freeze(l),m);
}
%InstallToContext(["get_template_call_site",GetTemplateCallSite]);
})

spread5
(function(a,b){
"use strict";
var c=b.InternalArray;
function SpreadArguments(){
var d=arguments.length;
var e=new c();
for(var f=0;f<d;++f){
var g=arguments[f];
var h=g.length;
for(var i=0;i<h;++i){
e.push(g[i]);
}
}
return e;
}
function SpreadIterable(j){
if((j==null)){
throw %make_type_error(73,j);
}
var e=new c();
for(var k of j){
e.push(k);
}
return e;
}
%InstallToContext([
"spread_arguments",SpreadArguments,
"spread_iterable",SpreadIterable,
]);
})

proxya
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Proxy;
%DefineMethodsInternal(c,class{revocable(target,handler){
var d=new c(target,handler);
return{proxy:d,revoke:()=>%JSProxyRevoke(d)};
}},-1);
})

intlîÏ
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c;
var d;
var e=a.Date;
var f=a.Intl;
var g=f.DateTimeFormat;
var h=f.NumberFormat;
var i=f.Collator;
var j=f.v8BreakIterator;
var k=a.Number;
var l=a.RegExp;
var m=a.String;
var n=b.ImportNow("intl_fallback_symbol");
var o=b.InternalArray;
var p;
var q=a.Object.prototype.hasOwnProperty;
var r=b.ImportNow("intl_pattern_symbol");
var s=b.ImportNow("intl_resolved_symbol");
var t=m.prototype.substr;
var u=m.prototype.substring;
b.Import(function(v){
c=v.ArrayJoin;
d=v.ArrayPush;
p=v.MaxSimple;
});
function AddBoundMethod(obj,methodName,implementation,length,typename,
compat){
%CheckIsBootstrapping();
var w=%CreatePrivateSymbol(methodName);
%DefineMethodsInternal(obj.prototype,class{get[methodName](){
var x=Unwrap(this,typename,obj,methodName,compat);
if((x[w]===(void 0))){
var y;
if((length===(void 0))||length===2){
y=
(0,((fst,snd)=>implementation(x,fst,snd)));
}else if(length===1){
y=(0,(fst=>implementation(x,fst)));
}else{
y=(0,((...args)=>{
if(args.length>0){
return implementation(x,args[0]);
}else{
return implementation(x);
}
}));
}
%SetNativeFlag(y);
x[w]=y;
}
return x[w];
}},-1);
}
function IntlConstruct(x,constructor,create,newTarget,args,
compat){
var z=args[0];
var A=args[1];
var B=create(z,A);
if(compat&&(newTarget===(void 0))&&x instanceof constructor){
%object_define_property(x,n,{value:B});
return x;
}
return B;
}
function Unwrap(x,C,D,E,F){
if(!%IsInitializedIntlObjectOfType(x,C)){
if(F&&x instanceof D){
let fallback=x[n];
if(%IsInitializedIntlObjectOfType(fallback,C)){
return fallback;
}
}
throw %make_type_error(48,E,x);
}
return x;
}
var G={
'collator':(void 0),
'numberformat':(void 0),
'dateformat':(void 0),
'breakiterator':(void 0)
};
var H=(void 0);
function GetDefaultICULocaleJS(I){
if((H===(void 0))){
H=%GetDefaultICULocale();
}
return((I===(void 0))||
(%_Call(q,getAvailableLocalesOf(I),H)))
?H:"und";
}
var J=(void 0);
function GetUnicodeExtensionRE(){
if(((void 0)===(void 0))){
J=new l('-u(-[a-z0-9]{2,8})+','g');
}
return J;
}
var K=(void 0);
function GetAnyExtensionRE(){
if((K===(void 0))){
K=new l('-[a-z0-9]{1}-.*','g');
}
return K;
}
var L=(void 0);
function GetQuotedStringRE(){
if((L===(void 0))){
L=new l("'[^']+'",'g');
}
return L;
}
var M=(void 0);
function GetServiceRE(){
if((M===(void 0))){
M=
new l('^(collator|numberformat|dateformat|breakiterator)$');
}
return M;
}
var N=(void 0);
function GetLanguageTagRE(){
if((N===(void 0))){
BuildLanguageTagREs();
}
return N;
}
var O=(void 0);
function GetLanguageVariantRE(){
if((O===(void 0))){
BuildLanguageTagREs();
}
return O;
}
var P=(void 0);
function GetLanguageSingletonRE(){
if((P===(void 0))){
BuildLanguageTagREs();
}
return P;
}
var Q=(void 0);
function GetTimezoneNameCheckRE(){
if((Q===(void 0))){
Q=new l(
'^([A-Za-z]+)/([A-Za-z_-]+)((?:\/[A-Za-z_-]+)+)*$');
}
return Q;
}
var R=(void 0);
function GetTimezoneNameLocationPartRE(){
if((R===(void 0))){
R=
new l('^([A-Za-z]+)((?:[_-][A-Za-z]+)+)*$');
}
return R;
}
function supportedLocalesOf(I,z,A){
if((%regexp_internal_match(GetServiceRE(),I)===null)){
throw %make_error(7,I);
}
if((A===(void 0))){
A={};
}else{
A=(%_ToObject(A));
}
var S=A.localeMatcher;
if(!(S===(void 0))){
S=(%_ToString(S));
if(S!=='lookup'&&S!=='best fit'){
throw %make_range_error(176,S);
}
}else{
S='best fit';
}
var T=initializeLocaleList(z);
var U=getAvailableLocalesOf(I);
if(S==='best fit'){
return initializeLocaleList(bestFitSupportedLocalesOf(
T,U));
}
return initializeLocaleList(lookupSupportedLocalesOf(
T,U));
}
function lookupSupportedLocalesOf(T,U){
var V=new o();
for(var W=0;W<T.length;++W){
var X=%RegExpInternalReplace(
GetUnicodeExtensionRE(),T[W],'');
do{
if(!(U[X]===(void 0))){
%_Call(d,V,T[W]);
break;
}
var Y=%StringLastIndexOf(X,'-');
if(Y===-1){
break;
}
X=%_Call(u,X,0,Y);
}while(true);
}
return V;
}
function bestFitSupportedLocalesOf(T,U){
return lookupSupportedLocalesOf(T,U);
}
function getGetOption(A,Z){
if((A===(void 0)))throw %make_error(4,Z);
var aa=function getOption(ab,ac,ad,ae){
if(!(A[ab]===(void 0))){
var af=A[ab];
switch(ac){
case'boolean':
af=(!!(af));
break;
case'string':
af=(%_ToString(af));
break;
case'number':
af=(%_ToNumber(af));
break;
default:
throw %make_error(8);
}
if(!(ad===(void 0))&&%ArrayIndexOf(ad,af,0)===-1){
throw %make_range_error(186,af,Z,ab);
}
return af;
}
return ae;
}
return aa;
}
function resolveLocale(I,T,A){
T=initializeLocaleList(T);
var aa=getGetOption(A,I);
var S=aa('localeMatcher','string',
['lookup','best fit'],'best fit');
var ag;
if(S==='lookup'){
ag=lookupMatcher(I,T);
}else{
ag=bestFitMatcher(I,T);
}
return ag;
}
function lookupMatcher(I,T){
if((%regexp_internal_match(GetServiceRE(),I)===null)){
throw %make_error(7,I);
}
var U=getAvailableLocalesOf(I);
for(var W=0;W<T.length;++W){
var X=%RegExpInternalReplace(
GetAnyExtensionRE(),T[W],'');
do{
if(!(U[X]===(void 0))){
var ah=%regexp_internal_match(
GetUnicodeExtensionRE(),T[W]);
var ai=(ah===null)?'':ah[0];
return{locale:X,extension:ai,position:W};
}
var Y=%StringLastIndexOf(X,'-');
if(Y===-1){
break;
}
X=%_Call(u,X,0,Y);
}while(true);
}
return{
locale:GetDefaultICULocaleJS(I),
extension:'',
position:-1
};
}
function bestFitMatcher(I,T){
return lookupMatcher(I,T);
}
function parseExtension(ai){
var aj=%StringSplit(ai,'-',4294967295);
if(aj.length<=2||
(aj[0]!==''&&aj[1]!=='u')){
return{};
}
var ak={};
var al=(void 0);
var af=(void 0);
for(var W=2;W<aj.length;++W){
var am=aj[W].length;
var an=aj[W];
if(am===2){
if(!(al===(void 0))){
if(!(al in ak)){
ak[al]=af;
}
af=(void 0);
}
al=an;
}else if(am>=3&&am<=8&&!(al===(void 0))){
if((af===(void 0))){
af=an;
}else{
af=af+"-"+an;
}
}else{
return{};
}
}
if(!(al===(void 0))&&!(al in ak)){
ak[al]=af;
}
return ak;
}
function setOptions(ao,ak,ap,aa,aq){
var ai='';
var ar=function updateExtension(al,af){
return'-'+al+'-'+(%_ToString(af));
}
var as=function updateProperty(ab,ac,af){
if(ac==='boolean'&&(typeof af==='string')){
af=(af==='true')?true:false;
}
if(!(ab===(void 0))){
defineWEProperty(aq,ab,af);
}
}
for(var al in ap){
if((%_Call(q,ap,al))){
var af=(void 0);
var at=ap[al];
if(!(at.property===(void 0))){
af=aa(at.property,at.type,at.values);
}
if(!(af===(void 0))){
as(at.property,at.type,af);
ai+=ar(al,af);
continue;
}
if((%_Call(q,ak,al))){
af=ak[al];
if(!(af===(void 0))){
as(at.property,at.type,af);
ai+=ar(al,af);
}else if(at.type==='boolean'){
as(at.property,at.type,true);
ai+=ar(al,true);
}
}
}
}
return ai===''?'':'-u'+ai;
}
function freezeArray(au){
var av=[];
var aw=au.length;
for(var W=0;W<aw;W++){
if(W in au){
%object_define_property(av,W,{value:au[W],
configurable:false,
writable:false,
enumerable:true});
}
}
%object_define_property(av,'length',{value:aw,writable:false});
return av;
}
function makeArray(au){
var av=[];
%MoveArrayContents(au,av);
return av;
}
function getAvailableLocalesOf(I){
if(!(G[I]===(void 0))){
return G[I];
}
var ax=%AvailableLocalesOf(I);
for(var W in ax){
if((%_Call(q,ax,W))){
var ay=%regexp_internal_match(
/^([a-z]{2,3})-([A-Z][a-z]{3})-([A-Z]{2})$/,W);
if(!(ay===null)){
ax[ay[1]+'-'+ay[3]]=null;
}
}
}
G[I]=ax;
return ax;
}
function defineWEProperty(az,ab,af){
%object_define_property(az,ab,
{value:af,writable:true,enumerable:true});
}
function addWEPropertyIfDefined(az,ab,af){
if(!(af===(void 0))){
defineWEProperty(az,ab,af);
}
}
function defineWECProperty(az,ab,af){
%object_define_property(az,ab,{value:af,
writable:true,
enumerable:true,
configurable:true});
}
function addWECPropertyIfDefined(az,ab,af){
if(!(af===(void 0))){
defineWECProperty(az,ab,af);
}
}
function toTitleCaseWord(aA){
return %StringToUpperCaseIntl(%_Call(t,aA,0,1))+
%StringToLowerCaseIntl(%_Call(t,aA,1));
}
function toTitleCaseTimezoneLocation(aB){
var aC=%regexp_internal_match(GetTimezoneNameLocationPartRE(),aB)
if((aC===null))throw %make_range_error(155,aB);
var aD=toTitleCaseWord(aC[1]);
if(!(aC[2]===(void 0))&&2<aC.length){
var aE=%_Call(u,aC[2],0,1);
var ay=%StringSplit(aC[2],aE,4294967295);
for(var W=1;W<ay.length;W++){
var aF=ay[W]
var aG=%StringToLowerCaseIntl(aF);
aD=aD+aE+
((aG!=='es'&&
aG!=='of'&&aG!=='au')?
toTitleCaseWord(aF):aG);
}
}
return aD;
}
function canonicalizeLanguageTag(aH){
if((!(typeof(aH)==='string')&&!(%_IsJSReceiver(aH)))||
(aH===null)){
throw %make_type_error(55);
}
if((typeof(aH)==='string')&&
!(%regexp_internal_match(/^[a-z]{2,3}$/,aH)===null)){
return aH;
}
var aI=(%_ToString(aH));
if(isStructuallyValidLanguageTag(aI)===false){
throw %make_range_error(167,aI);
}
var aJ=%CanonicalizeLanguageTag(aI);
if(aJ==='invalid-tag'){
throw %make_range_error(167,aI);
}
return aJ;
}
function canonicalizeLocaleList(z){
var aK=new o();
if(!(z===(void 0))){
if(typeof z==='string'){
%_Call(d,aK,canonicalizeLanguageTag(z));
return aK;
}
var aL=(%_ToObject(z));
var aM=(%_ToLength(aL.length));
for(var aN=0;aN<aM;aN++){
if(aN in aL){
var af=aL[aN];
var aJ=canonicalizeLanguageTag(af);
if(%ArrayIndexOf(aK,aJ,0)===-1){
%_Call(d,aK,aJ);
}
}
}
}
return aK;
}
function initializeLocaleList(z){
return freezeArray(canonicalizeLocaleList(z));
}
function isStructuallyValidLanguageTag(X){
if((%regexp_internal_match(GetLanguageTagRE(),X)===null)){
return false;
}
X=%StringToLowerCaseIntl(X);
if(%StringIndexOf(X,'x-',0)===0){
return true;
}
X=%StringSplit(X,'-x-',4294967295)[0];
var aO=new o();
var aP=new o();
var ay=%StringSplit(X,'-',4294967295);
for(var W=1;W<ay.length;W++){
var af=ay[W];
if(!(%regexp_internal_match(GetLanguageVariantRE(),af)===null)&&
aP.length===0){
if(%ArrayIndexOf(aO,af,0)===-1){
%_Call(d,aO,af);
}else{
return false;
}
}
if(!(%regexp_internal_match(GetLanguageSingletonRE(),af)===null)){
if(%ArrayIndexOf(aP,af,0)===-1){
%_Call(d,aP,af);
}else{
return false;
}
}
}
return true;
}
function BuildLanguageTagREs(){
var aQ='[a-zA-Z]';
var aR='[0-9]';
var aS='('+aQ+'|'+aR+')';
var aT='(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|'+
'zh-min|zh-min-nan|zh-xiang)';
var aU='(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|'+
'i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|'+
'i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)';
var aV='('+aU+'|'+aT+')';
var aW='(x(-'+aS+'{1,8})+)';
var aX='('+aR+'|[A-WY-Za-wy-z])';
P=new l('^'+aX+'$','i');
var ai='('+aX+'(-'+aS+'{2,8})+)';
var aY='('+aS+'{5,8}|('+aR+aS+'{3}))';
O=new l('^'+aY+'$','i');
var aZ='('+aQ+'{2}|'+aR+'{3})';
var ba='('+aQ+'{4})';
var bb='('+aQ+'{3}(-'+aQ+'{3}){0,2})';
var bc='('+aQ+'{2,3}(-'+bb+')?|'+aQ+'{4}|'+
aQ+'{5,8})';
var bd=bc+'(-'+ba+')?(-'+aZ+')?(-'+
aY+')*(-'+ai+')*(-'+aW+')?';
var be=
'^('+bd+'|'+aW+'|'+aV+')$';
N=new l(be,'i');
}
%DefineMethodsInternal(f,class{getCanonicalLocales(z){
return makeArray(canonicalizeLocaleList(z));
}},-1);
function CreateCollator(z,A){
if((A===(void 0))){
A={};
}
var aa=getGetOption(A,'collator');
var bf={};
defineWEProperty(bf,'usage',aa(
'usage','string',['sort','search'],'sort'));
var bg=aa('sensitivity','string',
['base','accent','case','variant']);
if((bg===(void 0))&&bf.usage==='sort'){
bg='variant';
}
defineWEProperty(bf,'sensitivity',bg);
defineWEProperty(bf,'ignorePunctuation',aa(
'ignorePunctuation','boolean',(void 0),false));
var X=resolveLocale('collator',z,A);
var ak=parseExtension(X.extension);
var bh={
'kn':{'property':'numeric','type':'boolean'},
'kf':{'property':'caseFirst','type':'string',
'values':['false','lower','upper']}
};
setOptions(
A,ak,bh,aa,bf);
var bi='default';
var ai='';
if((%_Call(q,ak,'co'))&&bf.usage==='sort'){
var bj=[
'big5han','dict','direct','ducet','gb2312','phonebk','phonetic',
'pinyin','reformed','searchjl','stroke','trad','unihan','zhuyin'
];
if(%ArrayIndexOf(bj,ak.co,0)!==-1){
ai='-u-co-'+ak.co;
bi=ak.co;
}
}else if(bf.usage==='search'){
ai='-u-co-search';
}
defineWEProperty(bf,'collation',bi);
var bk=X.locale+ai;
var ag=%object_define_properties({},{
caseFirst:{writable:true},
collation:{value:bf.collation,writable:true},
ignorePunctuation:{writable:true},
locale:{writable:true},
numeric:{writable:true},
requestedLocale:{value:bk,writable:true},
sensitivity:{writable:true},
strength:{writable:true},
usage:{value:bf.usage,writable:true}
});
var bl=%CreateCollator(bk,bf,ag);
%MarkAsInitializedIntlObjectOfType(bl,'collator');
bl[s]=ag;
return bl;
}
function CollatorConstructor(){
return IntlConstruct(this,i,CreateCollator,new.target,
arguments);
}
%SetCode(i,CollatorConstructor);
%DefineMethodsInternal(i.prototype,class{resolvedOptions(){
var bm=Unwrap(this,'collator',i,'resolvedOptions',
false);
return{
locale:bm[s].locale,
usage:bm[s].usage,
sensitivity:bm[s].sensitivity,
ignorePunctuation:bm[s].ignorePunctuation,
numeric:bm[s].numeric,
caseFirst:bm[s].caseFirst,
collation:bm[s].collation
};
}},-1);
%DefineMethodsInternal(i,class{supportedLocalesOf(z){
return supportedLocalesOf('collator',z,arguments[1]);
}},-1);
function compare(bl,bn,bo){
return %InternalCompare(bl,(%_ToString(bn)),(%_ToString(bo)));
};
AddBoundMethod(i,'compare',compare,2,'collator',false);
function isWellFormedCurrencyCode(bp){
return typeof bp==="string"&&bp.length===3&&
(%regexp_internal_match(/[^A-Za-z]/,bp)===null);
}
function defaultNumberOption(af,bq,br,bs,ab){
if(!(af===(void 0))){
af=(%_ToNumber(af));
if((%IS_VAR(af)!==af)||af<bq||af>br){
throw %make_range_error(179,ab);
}
return %math_floor(af);
}
return bs;
}
function getNumberOption(A,ab,bq,br,bs){
var af=A[ab];
return defaultNumberOption(af,bq,br,bs,ab);
}
function SetNumberFormatDigitOptions(bf,A,
mnfdDefault,mxfdDefault){
var bt=getNumberOption(A,'minimumIntegerDigits',1,21,1);
defineWEProperty(bf,'minimumIntegerDigits',bt);
var bu=getNumberOption(A,'minimumFractionDigits',0,20,
mnfdDefault);
defineWEProperty(bf,'minimumFractionDigits',bu);
var bv=p(bu,mxfdDefault);
var bw=getNumberOption(A,'maximumFractionDigits',bu,20,
bv);
defineWEProperty(bf,'maximumFractionDigits',bw);
var bx=A['minimumSignificantDigits'];
var by=A['maximumSignificantDigits'];
if(!(bx===(void 0))||!(by===(void 0))){
bx=defaultNumberOption(bx,1,21,1,'minimumSignificantDigits');
defineWEProperty(bf,'minimumSignificantDigits',bx);
by=defaultNumberOption(by,bx,21,21,'maximumSignificantDigits');
defineWEProperty(bf,'maximumSignificantDigits',by);
}
}
function CreateNumberFormat(z,A){
if((A===(void 0))){
A={};
}
var aa=getGetOption(A,'numberformat');
var X=resolveLocale('numberformat',z,A);
var bf={};
defineWEProperty(bf,'style',aa(
'style','string',['decimal','percent','currency'],'decimal'));
var bp=aa('currency','string');
if(!(bp===(void 0))&&!isWellFormedCurrencyCode(bp)){
throw %make_range_error(162,bp);
}
if(bf.style==='currency'&&(bp===(void 0))){
throw %make_type_error(31);
}
var bz,bA;
var bB=aa(
'currencyDisplay','string',['code','symbol','name'],'symbol');
if(bf.style==='currency'){
defineWEProperty(bf,'currency',%StringToUpperCaseIntl(bp));
defineWEProperty(bf,'currencyDisplay',bB);
bz=bA=%CurrencyDigits(bf.currency);
}else{
bz=0;
bA=bf.style==='percent'?0:3;
}
SetNumberFormatDigitOptions(bf,A,bz,
bA);
defineWEProperty(bf,'useGrouping',aa(
'useGrouping','boolean',(void 0),true));
var ak=parseExtension(X.extension);
var bC={
'nu':{'property':(void 0),'type':'string'}
};
var ai=setOptions(A,ak,bC,
aa,bf);
var bk=X.locale+ai;
var ag=%object_define_properties({},{
currency:{writable:true},
currencyDisplay:{writable:true},
locale:{writable:true},
maximumFractionDigits:{writable:true},
minimumFractionDigits:{writable:true},
minimumIntegerDigits:{writable:true},
numberingSystem:{writable:true},
requestedLocale:{value:bk,writable:true},
style:{value:bf.style,writable:true},
useGrouping:{writable:true}
});
if((%_Call(q,bf,'minimumSignificantDigits'))){
defineWEProperty(ag,'minimumSignificantDigits',(void 0));
}
if((%_Call(q,bf,'maximumSignificantDigits'))){
defineWEProperty(ag,'maximumSignificantDigits',(void 0));
}
var bD=%CreateNumberFormat(bk,bf,
ag);
if(bf.style==='currency'){
%object_define_property(ag,'currencyDisplay',
{value:bB,writable:true});
}
%MarkAsInitializedIntlObjectOfType(bD,'numberformat');
bD[s]=ag;
return bD;
}
function NumberFormatConstructor(){
return IntlConstruct(this,h,CreateNumberFormat,
new.target,arguments,true);
}
%SetCode(h,NumberFormatConstructor);
%DefineMethodsInternal(h.prototype,class{resolvedOptions(){
var bE=Unwrap(this,'numberformat',h,
'resolvedOptions',true);
var aD={
locale:bE[s].locale,
numberingSystem:bE[s].numberingSystem,
style:bE[s].style,
useGrouping:bE[s].useGrouping,
minimumIntegerDigits:bE[s].minimumIntegerDigits,
minimumFractionDigits:bE[s].minimumFractionDigits,
maximumFractionDigits:bE[s].maximumFractionDigits,
};
if(aD.style==='currency'){
defineWECProperty(aD,'currency',bE[s].currency);
defineWECProperty(aD,'currencyDisplay',
bE[s].currencyDisplay);
}
if((%_Call(q,bE[s],'minimumSignificantDigits'))){
defineWECProperty(aD,'minimumSignificantDigits',
bE[s].minimumSignificantDigits);
}
if((%_Call(q,bE[s],'maximumSignificantDigits'))){
defineWECProperty(aD,'maximumSignificantDigits',
bE[s].maximumSignificantDigits);
}
return aD;
}},-1);
%DefineMethodsInternal(h,class{supportedLocalesOf(z){
return supportedLocalesOf('numberformat',z,arguments[1]);
}},-1);
function formatNumber(bF,af){
var bG=(%_ToNumber(af))+0;
return %InternalNumberFormat(bF,bG);
}
AddBoundMethod(h,'format',formatNumber,1,
'numberformat',true);
function toLDMLString(A){
var aa=getGetOption(A,'dateformat');
var bH='';
var bI=aa('weekday','string',['narrow','short','long']);
bH+=appendToLDMLString(
bI,{narrow:'EEEEE',short:'EEE',long:'EEEE'});
bI=aa('era','string',['narrow','short','long']);
bH+=appendToLDMLString(
bI,{narrow:'GGGGG',short:'GGG',long:'GGGG'});
bI=aa('year','string',['2-digit','numeric']);
bH+=appendToLDMLString(bI,{'2-digit':'yy','numeric':'y'});
bI=aa('month','string',
['2-digit','numeric','narrow','short','long']);
bH+=appendToLDMLString(bI,{'2-digit':'MM','numeric':'M',
'narrow':'MMMMM','short':'MMM','long':'MMMM'});
bI=aa('day','string',['2-digit','numeric']);
bH+=appendToLDMLString(
bI,{'2-digit':'dd','numeric':'d'});
var bJ=aa('hour12','boolean');
bI=aa('hour','string',['2-digit','numeric']);
if((bJ===(void 0))){
bH+=appendToLDMLString(bI,{'2-digit':'jj','numeric':'j'});
}else if(bJ===true){
bH+=appendToLDMLString(bI,{'2-digit':'hh','numeric':'h'});
}else{
bH+=appendToLDMLString(bI,{'2-digit':'HH','numeric':'H'});
}
bI=aa('minute','string',['2-digit','numeric']);
bH+=appendToLDMLString(bI,{'2-digit':'mm','numeric':'m'});
bI=aa('second','string',['2-digit','numeric']);
bH+=appendToLDMLString(bI,{'2-digit':'ss','numeric':'s'});
bI=aa('timeZoneName','string',['short','long']);
bH+=appendToLDMLString(bI,{short:'z',long:'zzzz'});
return bH;
}
function appendToLDMLString(bI,bK){
if(!(bI===(void 0))){
return bK[bI];
}else{
return'';
}
}
function fromLDMLString(bH){
bH=%RegExpInternalReplace(GetQuotedStringRE(),bH,'');
var A={};
var aC=%regexp_internal_match(/E{3,5}/,bH);
A=appendToDateTimeObject(
A,'weekday',aC,{EEEEE:'narrow',EEE:'short',EEEE:'long'});
aC=%regexp_internal_match(/G{3,5}/,bH);
A=appendToDateTimeObject(
A,'era',aC,{GGGGG:'narrow',GGG:'short',GGGG:'long'});
aC=%regexp_internal_match(/y{1,2}/,bH);
A=appendToDateTimeObject(
A,'year',aC,{y:'numeric',yy:'2-digit'});
aC=%regexp_internal_match(/M{1,5}/,bH);
A=appendToDateTimeObject(A,'month',aC,{MM:'2-digit',
M:'numeric',MMMMM:'narrow',MMM:'short',MMMM:'long'});
aC=%regexp_internal_match(/L{1,5}/,bH);
A=appendToDateTimeObject(A,'month',aC,{LL:'2-digit',
L:'numeric',LLLLL:'narrow',LLL:'short',LLLL:'long'});
aC=%regexp_internal_match(/d{1,2}/,bH);
A=appendToDateTimeObject(
A,'day',aC,{d:'numeric',dd:'2-digit'});
aC=%regexp_internal_match(/h{1,2}/,bH);
if(aC!==null){
A['hour12']=true;
}
A=appendToDateTimeObject(
A,'hour',aC,{h:'numeric',hh:'2-digit'});
aC=%regexp_internal_match(/H{1,2}/,bH);
if(aC!==null){
A['hour12']=false;
}
A=appendToDateTimeObject(
A,'hour',aC,{H:'numeric',HH:'2-digit'});
aC=%regexp_internal_match(/m{1,2}/,bH);
A=appendToDateTimeObject(
A,'minute',aC,{m:'numeric',mm:'2-digit'});
aC=%regexp_internal_match(/s{1,2}/,bH);
A=appendToDateTimeObject(
A,'second',aC,{s:'numeric',ss:'2-digit'});
aC=%regexp_internal_match(/z|zzzz/,bH);
A=appendToDateTimeObject(
A,'timeZoneName',aC,{z:'short',zzzz:'long'});
return A;
}
function appendToDateTimeObject(A,bI,aC,bK){
if((aC===null)){
if(!(%_Call(q,A,bI))){
defineWEProperty(A,bI,(void 0));
}
return A;
}
var ab=aC[0];
defineWEProperty(A,bI,bK[ab]);
return A;
}
function toDateTimeOptions(A,bL,bM){
if((A===(void 0))){
A={};
}else{
A=(%_ToObject(A));
}
A=%object_create(A);
var bN=true;
if((bL==='date'||bL==='any')&&
(!(A.weekday===(void 0))||!(A.year===(void 0))||
!(A.month===(void 0))||!(A.day===(void 0)))){
bN=false;
}
if((bL==='time'||bL==='any')&&
(!(A.hour===(void 0))||!(A.minute===(void 0))||
!(A.second===(void 0)))){
bN=false;
}
if(bN&&(bM==='date'||bM==='all')){
%object_define_property(A,'year',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
%object_define_property(A,'month',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
%object_define_property(A,'day',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
}
if(bN&&(bM==='time'||bM==='all')){
%object_define_property(A,'hour',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
%object_define_property(A,'minute',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
%object_define_property(A,'second',{value:'numeric',
writable:true,
enumerable:true,
configurable:true});
}
return A;
}
function CreateDateTimeFormat(z,A){
if((A===(void 0))){
A={};
}
var X=resolveLocale('dateformat',z,A);
A=toDateTimeOptions(A,'any','date');
var aa=getGetOption(A,'dateformat');
var S=aa('formatMatcher','string',
['basic','best fit'],'best fit');
var bH=toLDMLString(A);
var bO=canonicalizeTimeZoneID(A.timeZone);
var bf={};
var ak=parseExtension(X.extension);
var bP={
'ca':{'property':(void 0),'type':'string'},
'nu':{'property':(void 0),'type':'string'}
};
var ai=setOptions(A,ak,bP,
aa,bf);
var bk=X.locale+ai;
var ag=%object_define_properties({},{
calendar:{writable:true},
day:{writable:true},
era:{writable:true},
hour12:{writable:true},
hour:{writable:true},
locale:{writable:true},
minute:{writable:true},
month:{writable:true},
numberingSystem:{writable:true},
[r]:{writable:true},
requestedLocale:{value:bk,writable:true},
second:{writable:true},
timeZone:{writable:true},
timeZoneName:{writable:true},
tz:{value:bO,writable:true},
weekday:{writable:true},
year:{writable:true}
});
var bQ=%CreateDateTimeFormat(
bk,{skeleton:bH,timeZone:bO},ag);
if(ag.timeZone==="Etc/Unknown"){
throw %make_range_error(185,bO);
}
%MarkAsInitializedIntlObjectOfType(bQ,'dateformat');
bQ[s]=ag;
return bQ;
}
function DateTimeFormatConstructor(){
return IntlConstruct(this,g,CreateDateTimeFormat,
new.target,arguments,true);
}
%SetCode(g,DateTimeFormatConstructor);
%DefineMethodsInternal(g.prototype,class{resolvedOptions(){
var bE=Unwrap(this,'dateformat',g,
'resolvedOptions',true);
var bR={
'gregorian':'gregory',
'ethiopic-amete-alem':'ethioaa'
};
var bS=fromLDMLString(bE[s][r]);
var bT=bR[bE[s].calendar];
if((bT===(void 0))){
bT=bE[s].calendar;
}
var aD={
locale:bE[s].locale,
numberingSystem:bE[s].numberingSystem,
calendar:bT,
timeZone:bE[s].timeZone
};
addWECPropertyIfDefined(aD,'timeZoneName',bS.timeZoneName);
addWECPropertyIfDefined(aD,'era',bS.era);
addWECPropertyIfDefined(aD,'year',bS.year);
addWECPropertyIfDefined(aD,'month',bS.month);
addWECPropertyIfDefined(aD,'day',bS.day);
addWECPropertyIfDefined(aD,'weekday',bS.weekday);
addWECPropertyIfDefined(aD,'hour12',bS.hour12);
addWECPropertyIfDefined(aD,'hour',bS.hour);
addWECPropertyIfDefined(aD,'minute',bS.minute);
addWECPropertyIfDefined(aD,'second',bS.second);
return aD;
}},-1);
%DefineMethodsInternal(g,class{supportedLocalesOf(z){
return supportedLocalesOf('dateformat',z,arguments[1]);
}},-1);
function formatDate(bF,bU){
var bV;
if((bU===(void 0))){
bV=%DateCurrentTime();
}else{
bV=(%_ToNumber(bU));
}
if(!(%_IsSmi(%IS_VAR(bV))||((bV==bV)&&(bV!=1/0)&&(bV!=-1/0))))throw %make_range_error(153);
return %InternalDateFormat(bF,new e(bV));
}
%DefineMethodsInternal(g.prototype,class{formatToParts(bU){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"Intl.DateTimeFormat.prototype.formatToParts");
if(!(typeof(this)==='object')){
throw %make_type_error(16,this);
}
if(!%IsInitializedIntlObjectOfType(this,'dateformat')){
throw %make_type_error(48,
'Intl.DateTimeFormat.prototype.formatToParts',
this);
}
var bV;
if((bU===(void 0))){
bV=%DateCurrentTime();
}else{
bV=(%_ToNumber(bU));
}
if(!(%_IsSmi(%IS_VAR(bV))||((bV==bV)&&(bV!=1/0)&&(bV!=-1/0))))throw %make_range_error(153);
return %InternalDateFormatToParts(this,new e(bV));
}},-1);
AddBoundMethod(g,'format',formatDate,1,'dateformat',
true);
function canonicalizeTimeZoneID(bW){
if((bW===(void 0))){
return bW;
}
bW=(%_ToString(bW));
var bX=%StringToUpperCaseIntl(bW);
if(bX==='UTC'||bX==='GMT'||
bX==='ETC/UTC'||bX==='ETC/GMT'){
return'UTC';
}
var aC=%regexp_internal_match(GetTimezoneNameCheckRE(),bW);
if((aC===null))throw %make_range_error(154,bW);
var aD=toTitleCaseTimezoneLocation(aC[1])+'/'+
toTitleCaseTimezoneLocation(aC[2]);
if(!(aC[3]===(void 0))&&3<aC.length){
var bY=%StringSplit(aC[3],'/',4294967295);
for(var W=1;W<bY.length;W++){
aD=aD+'/'+toTitleCaseTimezoneLocation(bY[W]);
}
}
return aD;
}
function CreateBreakIterator(z,A){
if((A===(void 0))){
A={};
}
var aa=getGetOption(A,'breakiterator');
var bf={};
defineWEProperty(bf,'type',aa(
'type','string',['character','word','sentence','line'],'word'));
var X=resolveLocale('breakiterator',z,A);
var ag=%object_define_properties({},{
requestedLocale:{value:X.locale,writable:true},
type:{value:bf.type,writable:true},
locale:{writable:true}
});
var bZ=%CreateBreakIterator(X.locale,bf,ag);
%MarkAsInitializedIntlObjectOfType(bZ,'breakiterator');
bZ[s]=ag;
return bZ;
}
function v8BreakIteratorConstructor(){
return IntlConstruct(this,j,CreateBreakIterator,
new.target,arguments);
}
%SetCode(j,v8BreakIteratorConstructor);
%DefineMethodsInternal(j.prototype,class{resolvedOptions(){
if(!(new.target===(void 0))){
throw %make_type_error(86);
}
var ca=Unwrap(this,'breakiterator',j,
'resolvedOptions',false);
return{
locale:ca[s].locale,
type:ca[s].type
};
}},-1);
%DefineMethodsInternal(j,class{supportedLocalesOf(z){
if(!(new.target===(void 0))){
throw %make_type_error(86);
}
return supportedLocalesOf('breakiterator',z,arguments[1]);
}},-1);
function adoptText(bZ,cb){
%BreakIteratorAdoptText(bZ,(%_ToString(cb)));
}
function first(bZ){
return %BreakIteratorFirst(bZ);
}
function next(bZ){
return %BreakIteratorNext(bZ);
}
function current(bZ){
return %BreakIteratorCurrent(bZ);
}
function breakType(bZ){
return %BreakIteratorBreakType(bZ);
}
AddBoundMethod(j,'adoptText',adoptText,1,
'breakiterator');
AddBoundMethod(j,'first',first,0,'breakiterator');
AddBoundMethod(j,'next',next,0,'breakiterator');
AddBoundMethod(j,'current',current,0,
'breakiterator');
AddBoundMethod(j,'breakType',breakType,0,
'breakiterator');
var cc={
'collator':i,
'numberformat':h,
'dateformatall':g,
'dateformatdate':g,
'dateformattime':g
};
var cd={
'collator':(void 0),
'numberformat':(void 0),
'dateformatall':(void 0),
'dateformatdate':(void 0),
'dateformattime':(void 0),
};
function clearDefaultObjects(){
cd['dateformatall']=(void 0);
cd['dateformatdate']=(void 0);
cd['dateformattime']=(void 0);
}
var ce=0;
function checkDateCacheCurrent(){
var cf=%DateCacheVersion();
if(cf==ce){
return;
}
ce=cf;
clearDefaultObjects();
}
function cachedOrNewService(I,z,A,bM){
var cg=((bM===(void 0)))?A:bM;
if((z===(void 0))&&(A===(void 0))){
checkDateCacheCurrent();
if((cd[I]===(void 0))){
cd[I]=new cc[I](z,cg);
}
return cd[I];
}
return new cc[I](z,cg);
}
function LocaleConvertCase(ch,z,ci){
var bc;
if((z===(void 0))){
bc=GetDefaultICULocaleJS();
}else if((typeof(z)==='string')){
bc=canonicalizeLanguageTag(z);
}else{
var z=initializeLocaleList(z);
bc=z.length>0?z[0]:GetDefaultICULocaleJS();
}
var Y=%StringIndexOf(bc,'-',0);
if(Y!==-1){
bc=%_Call(u,bc,0,Y);
}
return %StringLocaleConvertCase(ch,ci,bc);
}
%DefineMethodsInternal(m.prototype,class{localeCompare(that){
if((this==null)){
throw %make_type_error(57);
}
var z=arguments[1];
var A=arguments[2];
var bl=cachedOrNewService('collator',z,A);
return compare(bl,this,that);
}},-1);
var cj={};
%DefineMethodsInternal(m.prototype,class{
toLocaleLowerCase(z){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.toLocaleLowerCase");
return LocaleConvertCase((%_ToString(this)),z,false);
}
toLocaleUpperCase(z){
if((%IS_VAR(this)===null)||(this===(void 0)))throw %make_type_error(17,"String.prototype.toLocaleUpperCase");
return LocaleConvertCase((%_ToString(this)),z,true);
}
},0);
%DefineMethodsInternal(k.prototype,class{toLocaleString(){
if(!(this instanceof k)&&typeof(this)!=='number'){
throw %make_type_error(58,"Number");
}
var z=arguments[0];
var A=arguments[1];
var bD=cachedOrNewService('numberformat',z,A);
return formatNumber(bD,this);
}},-1);
function toLocaleDateTime(ck,z,A,bL,bM,I){
if(!(ck instanceof e)){
throw %make_type_error(58,"Date");
}
var bU=(%_ToNumber(ck));
if((%IS_VAR(bU)!==bU))return'Invalid Date';
var bf=toDateTimeOptions(A,bL,bM);
var bQ=
cachedOrNewService(I,z,A,bf);
return formatDate(bQ,ck);
}
%DefineMethodsInternal(e.prototype,class{toLocaleString(){
var z=arguments[0];
var A=arguments[1];
return toLocaleDateTime(
this,z,A,'any','all','dateformatall');
}},-1);
%DefineMethodsInternal(e.prototype,class{toLocaleDateString(){
var z=arguments[0];
var A=arguments[1];
return toLocaleDateTime(
this,z,A,'date','date','dateformatdate');
}},-1);
%DefineMethodsInternal(e.prototype,class{toLocaleTimeString(){
var z=arguments[0];
var A=arguments[1];
return toLocaleDateTime(
this,z,A,'time','time','dateformattime');
}},-1);
})

 4CommonStringsI
(function(global, binding, v8) {
  'use strict';
  binding.streamErrors = {
    illegalInvocation: 'Illegal invocation',
    illegalConstructor: 'Illegal constructor',
    invalidType: 'Invalid type is specified',
    invalidSize: 'The return value of a queuing strategy\'s size function must be a finite, non-NaN, non-negative number',
    sizeNotAFunction: 'A queuing strategy\'s size property must be a function',
    invalidHWM: 'A queueing strategy\'s highWaterMark property must be a nonnegative, non-NaN number',
  };
});
,SimpleQueue)
(function(global, binding, v8) {
  'use strict';
  const _front = v8.createPrivateSymbol('front');
  const _back = v8.createPrivateSymbol('back');
  const _cursor = v8.createPrivateSymbol('cursor');
  const _size = v8.createPrivateSymbol('size');
  const _elements = v8.createPrivateSymbol('elements');
  const _next = v8.createPrivateSymbol('next');
  const undefined = global.undefined;
  const RangeError = global.RangeError;
  function requireNonEmptyQueue(queue, functionName) {
    if (queue[_size] === 0) {
      throw new RangeError(
          `${functionName}() must not be called on an empty queue`);
    }
  }
  const QUEUE_MAX_ARRAY_SIZE = 16384;
  class SimpleQueue {
    constructor() {
      this[_front] = {
        [_elements]: new v8.InternalPackedArray(),
        [_next]: undefined,
      };
      this[_back] = this[_front];
      this[_cursor] = 0;
      this[_size] = 0;
    }
    get length() {
      return this[_size];
    }
    push(element) {
      const oldBack = this[_back];
      let newBack = oldBack;
      if (oldBack[_elements].length === QUEUE_MAX_ARRAY_SIZE - 1) {
        newBack = {
          [_elements]: new v8.InternalPackedArray(),
          [_next]: undefined,
        };
      }
      oldBack[_elements].push(element);
      if (newBack !== oldBack) {
        this[_back] = newBack;
        oldBack[_next] = newBack;
      }
      ++this[_size];
    }
    shift() {
      requireNonEmptyQueue(this, 'shift');
      const oldFront = this[_front];
      let newFront = oldFront;
      const oldCursor = this[_cursor];
      let newCursor = oldCursor + 1;
      const elements = oldFront[_elements];
      const element = elements[oldCursor];
      if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
        newFront = oldFront[_next];
        newCursor = 0;
      }
      --this[_size];
      this[_cursor] = newCursor;
      if (oldFront !== newFront) {
        this[_front] = newFront;
      }
      elements[oldCursor] = undefined;
      return element;
    }
    forEach(callback) {
      let i = this[_cursor];
      let node = this[_front];
      let elements = node[_elements];
      while (i !== elements.length || node[_next] !== undefined) {
        if (i === elements.length) {
          node = node[_next];
          elements = node[_elements];
          i = 0;
          if (elements.length === 0) {
            break;
          }
        }
        callback(elements[i]);
        ++i;
      }
    }
    peek() {
      requireNonEmptyQueue(this, 'peek');
      const front = this[_front];
      const cursor = this[_cursor];
      return front[_elements][cursor];
    }
  }
  binding.SimpleQueue = SimpleQueue;
});
dByteLengthQueuingStrategyÑ
(function(global, binding, v8) {
  'use strict';
  const defineProperty = global.Object.defineProperty;
  class ByteLengthQueuingStrategy {
    constructor(options) {
      defineProperty(this, 'highWaterMark', {
        value: options.highWaterMark,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    size(chunk) { return chunk.byteLength; }
  }
  defineProperty(global, 'ByteLengthQueuingStrategy', {
    value: ByteLengthQueuingStrategy,
    enumerable: false,
    configurable: true,
    writable: true
  });
});
PCountQueuingStrategyý
(function(global, binding, v8) {
  'use strict';
  const defineProperty = global.Object.defineProperty;
  class CountQueuingStrategy {
    constructor(options) {
      defineProperty(this, 'highWaterMark', {
        value: options.highWaterMark,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    size(chunk) { return 1; }
  }
  defineProperty(global, 'CountQueuingStrategy', {
    value: CountQueuingStrategy,
    enumerable: false,
    configurable: true,
    writable: true
  });
  class BuiltInCountQueuingStrategy {
    constructor(highWaterMark) {
      defineProperty(this, 'highWaterMark', {value: highWaterMark});
    }
    size(chunk) { return 1; }
  }
  binding.createBuiltInCountQueuingStrategy = highWaterMark =>
      new BuiltInCountQueuingStrategy(highWaterMark);
});
8ReadableStream
(function(global, binding, v8) {
  'use strict';
  const _reader = v8.createPrivateSymbol('[[reader]]');
  const _storedError = v8.createPrivateSymbol('[[storedError]]');
  const _controller = v8.createPrivateSymbol('[[controller]]');
  const _closedPromise = v8.createPrivateSymbol('[[closedPromise]]');
  const _ownerReadableStream =
      v8.createPrivateSymbol('[[ownerReadableStream]]');
  const _readRequests = v8.createPrivateSymbol('[[readRequests]]');
  const createWithExternalControllerSentinel =
      v8.createPrivateSymbol('flag for UA-created ReadableStream to pass');
  const _readableStreamBits = v8.createPrivateSymbol('bit field for [[state]] and [[disturbed]]');
  const DISTURBED = 0b1;
  const STATE_MASK = 0b110;
  const STATE_BITS_OFFSET = 1;
  const STATE_READABLE = 0;
  const STATE_CLOSED = 1;
  const STATE_ERRORED = 2;
  const _underlyingSource = v8.createPrivateSymbol('[[underlyingSource]]');
  const _controlledReadableStream =
      v8.createPrivateSymbol('[[controlledReadableStream]]');
  const _queue = v8.createPrivateSymbol('[[queue]]');
  const _totalQueuedSize = v8.createPrivateSymbol('[[totalQueuedSize]]');
  const _strategySize = v8.createPrivateSymbol('[[strategySize]]');
  const _strategyHWM = v8.createPrivateSymbol('[[strategyHWM]]');
  const _readableStreamDefaultControllerBits = v8.createPrivateSymbol(
      'bit field for [[started]], [[closeRequested]], [[pulling]], [[pullAgain]]');
  const STARTED = 0b1;
  const CLOSE_REQUESTED = 0b10;
  const PULLING = 0b100;
  const PULL_AGAIN = 0b1000;
  const EXTERNALLY_CONTROLLED = 0b10000;
  const undefined = global.undefined;
  const Infinity = global.Infinity;
  const defineProperty = global.Object.defineProperty;
  const hasOwnProperty = v8.uncurryThis(global.Object.hasOwnProperty);
  const callFunction = v8.uncurryThis(global.Function.prototype.call);
  const applyFunction = v8.uncurryThis(global.Function.prototype.apply);
  const TypeError = global.TypeError;
  const RangeError = global.RangeError;
  const Number = global.Number;
  const Number_isNaN = Number.isNaN;
  const Number_isFinite = Number.isFinite;
  const Promise = global.Promise;
  const thenPromise = v8.uncurryThis(Promise.prototype.then);
  const Promise_resolve = v8.simpleBind(Promise.resolve, Promise);
  const Promise_reject = v8.simpleBind(Promise.reject, Promise);
  const streamErrors = binding.streamErrors;
  const errCancelLockedStream =
      'Cannot cancel a readable stream that is locked to a reader';
  const errEnqueueCloseRequestedStream =
      'Cannot enqueue a chunk into a readable stream that is closed or has been requested to be closed';
  const errCancelReleasedReader =
      'This readable stream reader has been released and cannot be used to cancel its previous owner stream';
  const errReadReleasedReader =
      'This readable stream reader has been released and cannot be used to read from its previous owner stream';
  const errCloseCloseRequestedStream =
      'Cannot close a readable stream that has already been requested to be closed';
  const errEnqueueClosedStream = 'Cannot enqueue a chunk into a closed readable stream';
  const errEnqueueErroredStream = 'Cannot enqueue a chunk into an errored readable stream';
  const errCloseClosedStream = 'Cannot close a closed readable stream';
  const errCloseErroredStream = 'Cannot close an errored readable stream';
  const errErrorClosedStream = 'Cannot error a close readable stream';
  const errErrorErroredStream =
      'Cannot error a readable stream that is already errored';
  const errGetReaderNotByteStream = 'This readable stream does not support BYOB readers';
  const errGetReaderBadMode = 'Invalid reader mode given: expected undefined or "byob"';
  const errReaderConstructorBadArgument =
      'ReadableStreamReader constructor argument is not a readable stream';
  const errReaderConstructorStreamAlreadyLocked =
      'ReadableStreamReader constructor can only accept readable streams that are not yet locked to a reader';
  const errReleaseReaderWithPendingRead =
      'Cannot release a readable stream reader when it still has outstanding read() calls that have not yet settled';
  const errReleasedReaderClosedPromise =
      'This readable stream reader has been released and cannot be used to monitor the stream\'s state';
  const errTmplMustBeFunctionOrUndefined = name =>
      `${name} must be a function or undefined`;
  const errCannotPipeLockedStream = 'Cannot pipe a locked stream';
  const errCannotPipeToALockedStream = 'Cannot pipe to a locked stream';
  const errDestinationStreamClosed = 'Destination stream closed';
  function internalError() {
    throw new RangeError('ReadableStream Internal Error');
  }
  function rejectPromise(p, reason) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.rejectPromise(p, reason);
  }
  function resolvePromise(p, value) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.resolvePromise(p, value);
  }
  function markPromiseAsHandled(p) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.markPromiseAsHandled(p);
  }
  class ReadableStream {
    constructor() {
      const underlyingSource = arguments[0] === undefined ? {} : arguments[0];
      const strategy = arguments[1] === undefined ? {} : arguments[1];
      const size = strategy.size;
      let highWaterMark = strategy.highWaterMark;
      if (highWaterMark === undefined) {
        highWaterMark = 1;
      }
      this[_readableStreamBits] = 0b0;
      ReadableStreamSetState(this, STATE_READABLE);
      this[_reader] = undefined;
      this[_storedError] = undefined;
      this[_controller] = undefined;
      const type = underlyingSource.type;
      const typeString = String(type);
      if (typeString === 'bytes') {
        throw new RangeError('bytes type is not yet implemented');
      } else if (type !== undefined) {
        throw new RangeError(streamErrors.invalidType);
      }
      this[_controller] =
          new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark, arguments[2] === createWithExternalControllerSentinel);
    }
    get locked() {
      if (IsReadableStream(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      return IsReadableStreamLocked(this);
    }
    cancel(reason) {
      if (IsReadableStream(this) === false) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (IsReadableStreamLocked(this) === true) {
        return Promise_reject(new TypeError(errCancelLockedStream));
      }
      return ReadableStreamCancel(this, reason);
    }
    getReader({ mode } = {}) {
      if (IsReadableStream(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      if (mode === 'byob') {
        throw new TypeError(errGetReaderNotByteStream);
      }
      if (mode === undefined) {
        return AcquireReadableStreamDefaultReader(this);
      }
      throw new RangeError(errGetReaderBadMode);
    }
    pipeThrough({writable, readable}, options) {
      const promise = this.pipeTo(writable, options);
      if (v8.isPromise(promise)) {
        markPromiseAsHandled(promise);
      }
      return readable;
    }
    pipeTo(dest, {preventClose, preventAbort, preventCancel} = {}) {
      if (!IsReadableStream(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (!binding.IsWritableStream(dest)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      preventClose = Boolean(preventClose);
      preventAbort = Boolean(preventAbort);
      preventCancel = Boolean(preventCancel);
      if (IsReadableStreamLocked(this)) {
        return Promise_reject(new TypeError(errCannotPipeLockedStream));
      }
      if (binding.IsWritableStreamLocked(dest)) {
        return Promise_reject(new TypeError(errCannotPipeToALockedStream));
      }
      return ReadableStreamPipeTo(this, dest, preventClose, preventAbort,
                                  preventCancel);
    }
    tee() {
      if (IsReadableStream(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      return ReadableStreamTee(this);
    }
  }
  function ReadableStreamPipeTo(readable, dest, preventClose, preventAbort,
                                preventCancel) {
    const reader = AcquireReadableStreamDefaultReader(readable);
    const writer = binding.AcquireWritableStreamDefaultWriter(dest);
    let shuttingDown = false;
    const promise = v8.createPromise();
    let reading = false;
    if (checkInitialState()) {
      thenPromise(reader[_closedPromise], onReaderClosed, readableError);
      thenPromise(
          binding.getWritableStreamDefaultWriterClosedPromise(writer),
          undefined, writableError);
      pump();
    }
    function checkInitialState() {
      const state = ReadableStreamGetState(readable);
      if (state === STATE_ERRORED) {
        readableError(readable[_storedError]);
        return false;
      }
      if (binding.isWritableStreamErrored(dest)) {
        writableError(binding.getWritableStreamStoredError(dest));
        return false;
      }
      if (state === STATE_CLOSED) {
        readableClosed();
        return false;
      }
      if (binding.isWritableStreamClosingOrClosed(dest)) {
        writableStartedClosed();
        return false;
      }
      return true;
    }
    function pump() {
      if (shuttingDown) {
        return;
      }
      const desiredSize =
          binding.WritableStreamDefaultWriterGetDesiredSize(writer);
      if (desiredSize === null) {
        return;
      }
      if (desiredSize <= 0) {
        thenPromise(
            binding.getWritableStreamDefaultWriterReadyPromise(writer), pump,
            writableError);
        return;
      }
      reading = true;
      thenPromise(
          ReadableStreamDefaultReaderRead(reader), readFulfilled, readRejected);
    }
    function readFulfilled({value, done}) {
      reading = false;
      if (shuttingDown) {
        return;
      }
      if (done) {
        readableClosed();
        return;
      }
      const write = binding.WritableStreamDefaultWriterWrite(writer, value);
      thenPromise(write, undefined, writableError);
      pump();
    }
    function readRejected() {
      reading = false;
      readableError(readable[_storedError]);
    }
    function onReaderClosed() {
      if (!reading) {
        readableClosed();
      }
    }
    function readableError(error) {
      if (!preventAbort) {
        shutdownWithAction(
            binding.WritableStreamAbort, [dest, error], error, true);
      } else {
        shutdown(error, true);
      }
    }
    function writableError(error) {
      if (!preventCancel) {
        shutdownWithAction(
            ReadableStreamCancel, [readable, error], error, true);
      } else {
        shutdown(error, true);
      }
    }
    function readableClosed() {
      if (!preventClose) {
        shutdownWithAction(
            binding.WritableStreamDefaultWriterCloseWithErrorPropagation,
            [writer]);
      } else {
        shutdown();
      }
    }
    function writableStartedClosed() {
      const destClosed = new TypeError(errDestinationStreamClosed);
      if (!preventCancel) {
        shutdownWithAction(
            ReadableStreamCancel, [readable, destClosed], destClosed, true);
      } else {
        shutdown(destClosed, true);
      }
    }
    function shutdownWithAction(
        action, args, originalError = undefined, errorGiven = false) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      const p = applyFunction(action, undefined, args);
      thenPromise(
          p, () => finalize(originalError, errorGiven),
          newError => finalize(newError, true));
    }
    function shutdown(error = undefined, errorGiven = false) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      finalize(error, errorGiven);
    }
    function finalize(error, errorGiven) {
      binding.WritableStreamDefaultWriterRelease(writer);
      ReadableStreamReaderGenericRelease(reader);
      if (errorGiven) {
        rejectPromise(promise, error);
      } else {
        resolvePromise(promise, undefined);
      }
    }
    return promise;
  }
  class ReadableStreamDefaultController {
    constructor(stream, underlyingSource, size, highWaterMark, isExternallyControlled) {
      if (IsReadableStream(stream) === false) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      if (stream[_controller] !== undefined) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      this[_controlledReadableStream] = stream;
      this[_underlyingSource] = underlyingSource;
      this[_queue] = new binding.SimpleQueue();
      this[_totalQueuedSize] = 0;
      this[_readableStreamDefaultControllerBits] = 0b0;
      if (isExternallyControlled === true) {
        this[_readableStreamDefaultControllerBits] |= EXTERNALLY_CONTROLLED;
      }
      const normalizedStrategy =
          ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
      this[_strategySize] = normalizedStrategy.size;
      this[_strategyHWM] = normalizedStrategy.highWaterMark;
      const controller = this;
      const startResult = CallOrNoop(
          underlyingSource, 'start', this, 'underlyingSource.start');
      thenPromise(Promise_resolve(startResult),
          () => {
            controller[_readableStreamDefaultControllerBits] |= STARTED;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          },
          r => {
            if (ReadableStreamGetState(stream) === STATE_READABLE) {
              ReadableStreamDefaultControllerError(controller, r);
            }
          });
    }
    get desiredSize() {
      if (IsReadableStreamDefaultController(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      return ReadableStreamDefaultControllerGetDesiredSize(this);
    }
    close() {
      if (IsReadableStreamDefaultController(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const stream = this[_controlledReadableStream];
      if (this[_readableStreamDefaultControllerBits] & CLOSE_REQUESTED) {
        throw new TypeError(errCloseCloseRequestedStream);
      }
      const state = ReadableStreamGetState(stream);
      if (state === STATE_ERRORED) {
        throw new TypeError(errCloseErroredStream);
      }
      if (state === STATE_CLOSED) {
        throw new TypeError(errCloseClosedStream);
      }
      return ReadableStreamDefaultControllerClose(this);
    }
    enqueue(chunk) {
      if (IsReadableStreamDefaultController(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const stream = this[_controlledReadableStream];
      if (this[_readableStreamDefaultControllerBits] & CLOSE_REQUESTED) {
        throw new TypeError(errEnqueueCloseRequestedStream);
      }
      const state = ReadableStreamGetState(stream);
      if (state === STATE_ERRORED) {
        throw new TypeError(errEnqueueErroredStream);
      }
      if (state === STATE_CLOSED) {
        throw new TypeError(errEnqueueClosedStream);
      }
      return ReadableStreamDefaultControllerEnqueue(this, chunk);
    }
    error(e) {
      if (IsReadableStreamDefaultController(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const stream = this[_controlledReadableStream];
      const state = ReadableStreamGetState(stream);
      if (state === STATE_ERRORED) {
        throw new TypeError(errErrorErroredStream);
      }
      if (state === STATE_CLOSED) {
        throw new TypeError(errErrorClosedStream);
      }
      return ReadableStreamDefaultControllerError(this, e);
    }
  }
  function ReadableStreamDefaultControllerCancel(controller, reason) {
    controller[_queue] = new binding.SimpleQueue();
    const underlyingSource = controller[_underlyingSource];
    return PromiseCallOrNoop(underlyingSource, 'cancel', reason, 'underlyingSource.cancel');
  }
  function ReadableStreamDefaultControllerPull(controller) {
    const stream = controller[_controlledReadableStream];
    if (controller[_queue].length > 0) {
      const chunk = DequeueValue(controller);
      if ((controller[_readableStreamDefaultControllerBits] & CLOSE_REQUESTED) &&
          controller[_queue].length === 0) {
        ReadableStreamClose(stream);
      } else {
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      return Promise_resolve(CreateIterResultObject(chunk, false));
    }
    const pendingPromise = ReadableStreamAddReadRequest(stream);
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    return pendingPromise;
  }
  function ReadableStreamAddReadRequest(stream) {
    const promise = v8.createPromise();
    stream[_reader][_readRequests].push(promise);
    return promise;
  }
  class ReadableStreamDefaultReader {
    constructor(stream) {
      if (IsReadableStream(stream) === false) {
        throw new TypeError(errReaderConstructorBadArgument);
      }
      if (IsReadableStreamLocked(stream) === true) {
        throw new TypeError(errReaderConstructorStreamAlreadyLocked);
      }
      ReadableStreamReaderGenericInitialize(this, stream);
      this[_readRequests] = new binding.SimpleQueue();
    }
    get closed() {
      if (IsReadableStreamDefaultReader(this) === false) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      return this[_closedPromise];
    }
    cancel(reason) {
      if (IsReadableStreamDefaultReader(this) === false) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      const stream = this[_ownerReadableStream];
      if (stream === undefined) {
        return Promise_reject(new TypeError(errCancelReleasedReader));
      }
      return ReadableStreamReaderGenericCancel(this, reason);
    }
    read() {
      if (IsReadableStreamDefaultReader(this) === false) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (this[_ownerReadableStream] === undefined) {
        return Promise_reject(new TypeError(errReadReleasedReader));
      }
      return ReadableStreamDefaultReaderRead(this);
    }
    releaseLock() {
      if (IsReadableStreamDefaultReader(this) === false) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const stream = this[_ownerReadableStream];
      if (stream === undefined) {
        return undefined;
      }
      if (this[_readRequests].length > 0) {
        throw new TypeError(errReleaseReaderWithPendingRead);
      }
      ReadableStreamReaderGenericRelease(this);
    }
  }
  function ReadableStreamReaderGenericCancel(reader, reason) {
    return ReadableStreamCancel(reader[_ownerReadableStream], reason);
  }
  function AcquireReadableStreamDefaultReader(stream) {
    return new ReadableStreamDefaultReader(stream);
  }
  function ReadableStreamCancel(stream, reason) {
    stream[_readableStreamBits] |= DISTURBED;
    const state = ReadableStreamGetState(stream);
    if (state === STATE_CLOSED) {
      return Promise_resolve(undefined);
    }
    if (state === STATE_ERRORED) {
      return Promise_reject(stream[_storedError]);
    }
    ReadableStreamClose(stream);
    const sourceCancelPromise = ReadableStreamDefaultControllerCancel(stream[_controller], reason);
    return thenPromise(sourceCancelPromise, () => undefined);
  }
  function ReadableStreamDefaultControllerClose(controller) {
    const stream = controller[_controlledReadableStream];
    controller[_readableStreamDefaultControllerBits] |= CLOSE_REQUESTED;
    if (controller[_queue].length === 0) {
      ReadableStreamClose(stream);
    }
  }
  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
    const reader = stream[_reader];
    const readRequest = stream[_reader][_readRequests].shift();
    resolvePromise(readRequest, CreateIterResultObject(chunk, done));
  }
  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
    const stream = controller[_controlledReadableStream];
    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
      ReadableStreamFulfillReadRequest(stream, chunk, false);
    } else {
      let chunkSize = 1;
      const strategySize = controller[_strategySize];
      if (strategySize !== undefined) {
        try {
          chunkSize = strategySize(chunk);
        } catch (chunkSizeE) {
          if (ReadableStreamGetState(stream) === STATE_READABLE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
          }
          throw chunkSizeE;
        }
      }
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        if (ReadableStreamGetState(stream) === STATE_READABLE) {
          ReadableStreamDefaultControllerError(controller, enqueueE);
        }
        throw enqueueE;
      }
    }
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }
  function ReadableStreamGetState(stream) {
    return (stream[_readableStreamBits] & STATE_MASK) >> STATE_BITS_OFFSET;
  }
  function ReadableStreamSetState(stream, state) {
    stream[_readableStreamBits] = (stream[_readableStreamBits] & ~STATE_MASK) |
        (state << STATE_BITS_OFFSET);
  }
  function ReadableStreamDefaultControllerError(controller, e) {
    controller[_queue] = new binding.SimpleQueue();
    const stream = controller[_controlledReadableStream];
    ReadableStreamError(stream, e);
  }
  function ReadableStreamError(stream, e) {
    stream[_storedError] = e;
    ReadableStreamSetState(stream, STATE_ERRORED);
    const reader = stream[_reader];
    if (reader === undefined) {
      return undefined;
    }
    if (IsReadableStreamDefaultReader(reader) === true) {
      reader[_readRequests].forEach(request => rejectPromise(request, e));
      reader[_readRequests] = new binding.SimpleQueue();
    }
    rejectPromise(reader[_closedPromise], e);
    markPromiseAsHandled(reader[_closedPromise]);
  }
  function ReadableStreamClose(stream) {
    ReadableStreamSetState(stream, STATE_CLOSED);
    const reader = stream[_reader];
    if (reader === undefined) {
      return undefined;
    }
    if (IsReadableStreamDefaultReader(reader) === true) {
      reader[_readRequests].forEach(request =>
          resolvePromise(request, CreateIterResultObject(undefined, true)));
      reader[_readRequests] = new binding.SimpleQueue();
    }
    resolvePromise(reader[_closedPromise], undefined);
  }
  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
    const queueSize = GetTotalQueueSize(controller);
    return controller[_strategyHWM] - queueSize;
  }
  function IsReadableStream(x) {
    return hasOwnProperty(x, _controller);
  }
  function IsReadableStreamDisturbed(stream) {
    return stream[_readableStreamBits] & DISTURBED;
  }
  function IsReadableStreamLocked(stream) {
    return stream[_reader] !== undefined;
  }
  function IsReadableStreamDefaultController(x) {
    return hasOwnProperty(x, _controlledReadableStream);
  }
  function IsReadableStreamDefaultReader(x) {
    return hasOwnProperty(x, _readRequests);
  }
  function IsReadableStreamReadable(stream) {
    return ReadableStreamGetState(stream) === STATE_READABLE;
  }
  function IsReadableStreamClosed(stream) {
    return ReadableStreamGetState(stream) === STATE_CLOSED;
  }
  function IsReadableStreamErrored(stream) {
    return ReadableStreamGetState(stream) === STATE_ERRORED;
  }
  function ReadableStreamReaderGenericInitialize(reader, stream) {
    const controller = stream[_controller];
    if (controller[_readableStreamDefaultControllerBits] & EXTERNALLY_CONTROLLED) {
      const underlyingSource = controller[_underlyingSource];
      callFunction(underlyingSource.notifyLockAcquired, underlyingSource);
    }
    reader[_ownerReadableStream] = stream;
    stream[_reader] = reader;
    switch (ReadableStreamGetState(stream)) {
      case STATE_READABLE:
        reader[_closedPromise] = v8.createPromise();
        break;
      case STATE_CLOSED:
        reader[_closedPromise] = Promise_resolve(undefined);
        break;
      case STATE_ERRORED:
        reader[_closedPromise] = Promise_reject(stream[_storedError]);
        markPromiseAsHandled(reader[_closedPromise]);
        break;
    }
  }
  function ReadableStreamReaderGenericRelease(reader) {
    const controller = reader[_ownerReadableStream][_controller];
    if (controller[_readableStreamDefaultControllerBits] & EXTERNALLY_CONTROLLED) {
      const underlyingSource = controller[_underlyingSource];
      callFunction(underlyingSource.notifyLockReleased, underlyingSource);
    }
    if (ReadableStreamGetState(reader[_ownerReadableStream]) === STATE_READABLE) {
      rejectPromise(reader[_closedPromise], new TypeError(errReleasedReaderClosedPromise));
    } else {
      reader[_closedPromise] = Promise_reject(new TypeError(errReleasedReaderClosedPromise));
    }
    markPromiseAsHandled(reader[_closedPromise]);
    reader[_ownerReadableStream][_reader] = undefined;
    reader[_ownerReadableStream] = undefined;
  }
  function ReadableStreamDefaultReaderRead(reader) {
    const stream = reader[_ownerReadableStream];
    stream[_readableStreamBits] |= DISTURBED;
    if (ReadableStreamGetState(stream) === STATE_CLOSED) {
      return Promise_resolve(CreateIterResultObject(undefined, true));
    }
    if (ReadableStreamGetState(stream) === STATE_ERRORED) {
      return Promise_reject(stream[_storedError]);
    }
    return ReadableStreamDefaultControllerPull(stream[_controller]);
  }
  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
    if (shouldPull === false) {
      return undefined;
    }
    if (controller[_readableStreamDefaultControllerBits] & PULLING) {
      controller[_readableStreamDefaultControllerBits] |= PULL_AGAIN;
      return undefined;
    }
    controller[_readableStreamDefaultControllerBits] |= PULLING;
    const underlyingSource = controller[_underlyingSource];
    const pullPromise = PromiseCallOrNoop(
        underlyingSource, 'pull', controller, 'underlyingSource.pull');
    thenPromise(pullPromise,
        () => {
          controller[_readableStreamDefaultControllerBits] &= ~PULLING;
          if (controller[_readableStreamDefaultControllerBits] & PULL_AGAIN) {
            controller[_readableStreamDefaultControllerBits] &= ~PULL_AGAIN;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        },
        e => {
          if (ReadableStreamGetState(controller[_controlledReadableStream]) === STATE_READABLE) {
            ReadableStreamDefaultControllerError(controller, e);
          }
        });
  }
  function ReadableStreamDefaultControllerShouldCallPull(controller) {
    const stream = controller[_controlledReadableStream];
    const state = ReadableStreamGetState(stream);
    if (state === STATE_CLOSED || state === STATE_ERRORED) {
      return false;
    }
    if (controller[_readableStreamDefaultControllerBits] & CLOSE_REQUESTED) {
      return false;
    }
    if (!(controller[_readableStreamDefaultControllerBits] & STARTED)) {
      return false;
    }
    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }
    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
    if (desiredSize > 0) {
      return true;
    }
    return false;
  }
  function ReadableStreamGetNumReadRequests(stream) {
    const reader = stream[_reader];
    const readRequests = reader[_readRequests];
    return readRequests.length;
  }
  function ReadableStreamTee(stream) {
    const reader = AcquireReadableStreamDefaultReader(stream);
    let closedOrErrored = false;
    let canceled1 = false;
    let canceled2 = false;
    let reason1;
    let reason2;
    let promise = v8.createPromise();
    const branch1Stream = new ReadableStream({pull, cancel: cancel1});
    const branch2Stream = new ReadableStream({pull, cancel: cancel2});
    const branch1 = branch1Stream[_controller];
    const branch2 = branch2Stream[_controller];
    thenPromise(
        reader[_closedPromise], undefined, function(r) {
          if (closedOrErrored === true) {
            return;
          }
          ReadableStreamDefaultControllerError(branch1, r);
          ReadableStreamDefaultControllerError(branch2, r);
          closedOrErrored = true;
        });
    return [branch1Stream, branch2Stream];
    function pull() {
      return thenPromise(
          ReadableStreamDefaultReaderRead(reader), function(result) {
            const value = result.value;
            const done = result.done;
            if (done === true && closedOrErrored === false) {
              if (canceled1 === false) {
                ReadableStreamDefaultControllerClose(branch1);
              }
              if (canceled2 === false) {
                ReadableStreamDefaultControllerClose(branch2);
              }
              closedOrErrored = true;
            }
            if (closedOrErrored === true) {
              return;
            }
            if (canceled1 === false) {
              ReadableStreamDefaultControllerEnqueue(branch1, value);
            }
            if (canceled2 === false) {
              ReadableStreamDefaultControllerEnqueue(branch2, value);
            }
          });
    }
    function cancel1(reason) {
      canceled1 = true;
      reason1 = reason;
      if (canceled2 === true) {
        const compositeReason = [reason1, reason2];
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolvePromise(promise, cancelResult);
      }
      return promise;
    }
    function cancel2(reason) {
      canceled2 = true;
      reason2 = reason;
      if (canceled1 === true) {
        const compositeReason = [reason1, reason2];
        const cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolvePromise(promise, cancelResult);
      }
      return promise;
    }
  }
  function DequeueValue(controller) {
    const result = controller[_queue].shift();
    controller[_totalQueuedSize] -= result.size;
    return result.value;
  }
  function EnqueueValueWithSize(controller, value, size) {
    size = Number(size);
    if (Number_isNaN(size) || size === +Infinity || size < 0) {
      throw new RangeError(streamErrors.invalidSize);
    }
    controller[_totalQueuedSize] += size;
    controller[_queue].push({value, size});
  }
  function GetTotalQueueSize(controller) { return controller[_totalQueuedSize]; }
  function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
    if (size !== undefined && typeof size !== 'function') {
      throw new TypeError(streamErrors.sizeNotAFunction);
    }
    highWaterMark = Number(highWaterMark);
    if (Number_isNaN(highWaterMark)) {
      throw new RangeError(streamErrors.invalidHWM);
    }
    if (highWaterMark < 0) {
      throw new RangeError(streamErrors.invalidHWM);
    }
    return {size, highWaterMark};
  }
  function CallOrNoop(O, P, arg, nameForError) {
    const method = O[P];
    if (method === undefined) {
      return undefined;
    }
    if (typeof method !== 'function') {
      throw new TypeError(errTmplMustBeFunctionOrUndefined(nameForError));
    }
    return callFunction(method, O, arg);
  }
  function PromiseCallOrNoop(O, P, arg, nameForError) {
    let method;
    try {
      method = O[P];
    } catch (methodE) {
      return Promise_reject(methodE);
    }
    if (method === undefined) {
      return Promise_resolve(undefined);
    }
    if (typeof method !== 'function') {
      return Promise_reject(new TypeError(errTmplMustBeFunctionOrUndefined(nameForError)));
    }
    try {
      return Promise_resolve(callFunction(method, O, arg));
    } catch (e) {
      return Promise_reject(e);
    }
  }
  function CreateIterResultObject(value, done) { return {value, done}; }
  defineProperty(global, 'ReadableStream', {
    value: ReadableStream,
    enumerable: false,
    configurable: true,
    writable: true
  });
  binding.AcquireReadableStreamDefaultReader = AcquireReadableStreamDefaultReader;
  binding.IsReadableStream = IsReadableStream;
  binding.IsReadableStreamDisturbed = IsReadableStreamDisturbed;
  binding.IsReadableStreamLocked = IsReadableStreamLocked;
  binding.IsReadableStreamReadable = IsReadableStreamReadable;
  binding.IsReadableStreamClosed = IsReadableStreamClosed;
  binding.IsReadableStreamErrored = IsReadableStreamErrored;
  binding.IsReadableStreamDefaultReader = IsReadableStreamDefaultReader;
  binding.ReadableStreamDefaultReaderRead = ReadableStreamDefaultReaderRead;
  binding.ReadableStreamTee = ReadableStreamTee;
  binding.ReadableStreamDefaultControllerClose = ReadableStreamDefaultControllerClose;
  binding.ReadableStreamDefaultControllerGetDesiredSize = ReadableStreamDefaultControllerGetDesiredSize;
  binding.ReadableStreamDefaultControllerEnqueue = ReadableStreamDefaultControllerEnqueue;
  binding.ReadableStreamDefaultControllerError = ReadableStreamDefaultControllerError;
  binding.createReadableStreamWithExternalController =
      (underlyingSource, strategy) => {
        return new ReadableStream(
            underlyingSource, strategy, createWithExternalControllerSentinel);
      };
});
8WritableStreamâá
(function(global, binding, v8) {
  'use strict';
  const _closeRequest = v8.createPrivateSymbol('[[closeRequest]]');
  const _inFlightWriteRequest = v8.createPrivateSymbol('[[inFlightWriteRequest]]');
  const _inFlightCloseRequest = v8.createPrivateSymbol('[[inFlightCloseRequest]]');
  const _pendingAbortRequest =
      v8.createPrivateSymbol('[[pendingAbortRequest]]');
  const _stateAndFlags = v8.createPrivateSymbol('[[state]] and flags');
  const _storedError = v8.createPrivateSymbol('[[storedError]]');
  const _writableStreamController =
      v8.createPrivateSymbol('[[writableStreamController]]');
  const _writer = v8.createPrivateSymbol('[[writer]]');
  const _writeRequests = v8.createPrivateSymbol('[[writeRequests]]');
  const _closedPromise = v8.createPrivateSymbol('[[closedPromise]]');
  const _ownerWritableStream =
      v8.createPrivateSymbol('[[ownerWritableStream]]');
  const _readyPromise = v8.createPrivateSymbol('[[readyPromise]]');
  const _controlledWritableStream =
      v8.createPrivateSymbol('[[controlledWritableStream]]');
  const _queue = v8.createPrivateSymbol('[[queue]]');
  const _queueTotalSize = v8.createPrivateSymbol('[[queueTotalSize]]');
  const _started = v8.createPrivateSymbol('[[started]]');
  const _strategyHWM = v8.createPrivateSymbol('[[strategyHWM]]');
  const _strategySize = v8.createPrivateSymbol('[[strategySize]]');
  const _underlyingSink = v8.createPrivateSymbol('[[underlyingSink]]');
  const WRITABLE = 0;
  const CLOSED = 1;
  const ERRORING = 2;
  const ERRORED = 3;
  const STATE_MASK = 0xF;
  const BACKPRESSURE_FLAG = 0x10;
  const undefined = global.undefined;
  const defineProperty = global.Object.defineProperty;
  const hasOwnProperty = v8.uncurryThis(global.Object.hasOwnProperty);
  const Function_apply = v8.uncurryThis(global.Function.prototype.apply);
  const Function_call = v8.uncurryThis(global.Function.prototype.call);
  const TypeError = global.TypeError;
  const RangeError = global.RangeError;
  const Boolean = global.Boolean;
  const Number = global.Number;
  const Number_isNaN = Number.isNaN;
  const Number_isFinite = Number.isFinite;
  const Promise = global.Promise;
  const thenPromise = v8.uncurryThis(Promise.prototype.then);
  const Promise_resolve = v8.simpleBind(Promise.resolve, Promise);
  const Promise_reject = v8.simpleBind(Promise.reject, Promise);
  const streamErrors = binding.streamErrors;
  const errAbortLockedStream = 'Cannot abort a writable stream that is locked to a writer';
  const errStreamAborted = 'The stream has been aborted';
  const errStreamAborting = 'The stream is in the process of being aborted';
  const errWriterLockReleasedPrefix = 'This writable stream writer has been released and cannot be ';
  const errCloseCloseRequestedStream =
      'Cannot close a writable stream that has already been requested to be closed';
  const errWriteCloseRequestedStream =
      'Cannot write to a writable stream that is due to be closed';
  const templateErrorCannotActionOnStateStream =
      (action, state) => `Cannot ${action} a ${state} writable stream`;
  const errReleasedWriterClosedPromise =
      'This writable stream writer has been released and cannot be used to monitor the stream\'s state';
  const templateErrorIsNotAFunction = f => `${f} is not a function`;
  const verbUsedToGetTheDesiredSize = 'used to get the desiredSize';
  const verbAborted = 'aborted';
  const verbClosed = 'closed';
  const verbWrittenTo = 'written to';
  function createWriterLockReleasedError(verb) {
    return new TypeError(errWriterLockReleasedPrefix + verb);
  }
  const stateNames = {[CLOSED]: 'closed', [ERRORED]: 'errored'};
  function createCannotActionOnStateStreamError(action, state) {
    return new TypeError(
        templateErrorCannotActionOnStateStream(action, stateNames[state]));
  }
  function internalError() {
    throw new RangeError('WritableStream Internal Error');
  }
  function rejectPromise(p, reason) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.rejectPromise(p, reason);
  }
  function resolvePromise(p, value) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.resolvePromise(p, value);
  }
  function markPromiseAsHandled(p) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    v8.markPromiseAsHandled(p);
  }
  function promiseState(p) {
    if (!v8.isPromise(p)) {
      internalError();
    }
    return v8.promiseState(p);
  }
  function rejectPromises(queue, e) {
    queue.forEach(promise => rejectPromise(promise, e));
  }
  class WritableStream {
    constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {
      this[_stateAndFlags] = WRITABLE;
      this[_storedError] = undefined;
      this[_writer] = undefined;
      this[_writableStreamController] = undefined;
      this[_inFlightWriteRequest] = undefined;
      this[_closeRequest] = undefined;
      this[_inFlightCloseRequest] = undefined;
      this[_pendingAbortRequest] = undefined;
      this[_writeRequests] = new binding.SimpleQueue();
      const type = underlyingSink.type;
      if (type !== undefined) {
        throw new RangeError(streamErrors.invalidType);
      }
      this[_writableStreamController] =
          new WritableStreamDefaultController(this, underlyingSink, size,
                                              highWaterMark);
      WritableStreamDefaultControllerStartSteps(this[_writableStreamController]);
    }
    get locked() {
      if (!IsWritableStream(this)) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      return IsWritableStreamLocked(this);
    }
    abort(reason) {
      if (!IsWritableStream(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (IsWritableStreamLocked(this)) {
        return Promise_reject(new TypeError(errAbortLockedStream));
      }
      return WritableStreamAbort(this, reason);
    }
    getWriter() {
      if (!IsWritableStream(this)) {
         throw new TypeError(streamErrors.illegalInvocation);
      }
      return AcquireWritableStreamDefaultWriter(this);
    }
  }
  function AcquireWritableStreamDefaultWriter(stream) {
    return new WritableStreamDefaultWriter(stream);
  }
  function IsWritableStream(x) {
    return hasOwnProperty(x, _writableStreamController);
  }
  function IsWritableStreamLocked(stream) {
    return stream[_writer] !== undefined;
  }
  function WritableStreamAbort(stream, reason) {
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === CLOSED) {
      return Promise_resolve(undefined);
    }
    if (state === ERRORED) {
      return Promise_reject(stream[_storedError]);
    }
    const error = new TypeError(errStreamAborting);
    if (stream[_pendingAbortRequest] !== undefined) {
      return Promise_reject(error);
    }
    const wasAlreadyErroring = state === ERRORING;
    if (wasAlreadyErroring) {
      reason = undefined;
    }
    const promise = v8.createPromise();
    stream[_pendingAbortRequest] = {promise, reason, wasAlreadyErroring};
    if (!wasAlreadyErroring) {
      WritableStreamStartErroring(stream, error);
    }
    return promise;
  }
  function WritableStreamAddWriteRequest(stream) {
    const promise = v8.createPromise();
    stream[_writeRequests].push(promise);
    return promise;
  }
  function WritableStreamDealWithRejection(stream, error) {
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === WRITABLE) {
      WritableStreamStartErroring(stream, error);
      return;
    }
    WritableStreamFinishErroring(stream);
  }
  function WritableStreamStartErroring(stream, reason) {
    const controller = stream[_writableStreamController];
    stream[_stateAndFlags] = (stream[_stateAndFlags] & ~STATE_MASK) | ERRORING;
    stream[_storedError] = reason;
    const writer = stream[_writer];
    if (writer !== undefined) {
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
    }
    if (!WritableStreamHasOperationMarkedInFlight(stream) &&
        controller[_started]) {
      WritableStreamFinishErroring(stream);
    }
  }
  function WritableStreamFinishErroring(stream) {
    stream[_stateAndFlags] = (stream[_stateAndFlags] & ~STATE_MASK) | ERRORED;
    WritableStreamDefaultControllerErrorSteps(
        stream[_writableStreamController]);
    const storedError = stream[_storedError];
    rejectPromises(stream[_writeRequests], storedError);
    stream[_writeRequests] = new binding.SimpleQueue();
    if (stream[_pendingAbortRequest] === undefined) {
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const abortRequest = stream[_pendingAbortRequest];
    stream[_pendingAbortRequest] = undefined;
    if (abortRequest.wasAlreadyErroring === true) {
      rejectPromise(abortRequest.promise, storedError);
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }
    const promise = WritableStreamDefaultControllerAbortSteps(
        stream[_writableStreamController], abortRequest.reason);
    thenPromise(
        promise,
        () => {
          resolvePromise(abortRequest.promise, undefined);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        },
        reason => {
          rejectPromise(abortRequest.promise, reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
  }
  function WritableStreamFinishInFlightWrite(stream) {
    resolvePromise(stream[_inFlightWriteRequest], undefined);
    stream[_inFlightWriteRequest] = undefined;
  }
  function WritableStreamFinishInFlightWriteWithError(stream, error) {
    rejectPromise(stream[_inFlightWriteRequest], error);
    stream[_inFlightWriteRequest] = undefined;
    let state = stream[_stateAndFlags] & STATE_MASK;
    WritableStreamDealWithRejection(stream, error);
  }
  function WritableStreamFinishInFlightClose(stream) {
    resolvePromise(stream[_inFlightCloseRequest], undefined);
    stream[_inFlightCloseRequest] = undefined;
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === ERRORING) {
      stream[_storedError] = undefined;
      if (stream[_pendingAbortRequest] !== undefined) {
        resolvePromise(stream[_pendingAbortRequest].promise, undefined);
        stream[_pendingAbortRequest] = undefined;
      }
    }
    stream[_stateAndFlags] = (stream[_stateAndFlags] & ~STATE_MASK) | CLOSED;
    const writer = stream[_writer];
    if (writer !== undefined) {
      resolvePromise(writer[_closedPromise], undefined);
    }
  }
  function WritableStreamFinishInFlightCloseWithError(stream, error) {
    rejectPromise(stream[_inFlightCloseRequest], error);
    stream[_inFlightCloseRequest] = undefined;
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (stream[_pendingAbortRequest] !== undefined) {
      rejectPromise(stream[_pendingAbortRequest].promise, error);
      stream[_pendingAbortRequest] = undefined;
    }
    WritableStreamDealWithRejection(stream, error);
  }
  function WritableStreamCloseQueuedOrInFlight(stream) {
    return stream[_closeRequest] !== undefined ||
        stream[_inFlightCloseRequest] !== undefined;
  }
  function WritableStreamHasOperationMarkedInFlight(stream) {
    return stream[_inFlightWriteRequest] !== undefined ||
        stream[_inFlightCloseRequest] !== undefined;
  }
  function WritableStreamMarkCloseRequestInFlight(stream) {
    stream[_inFlightCloseRequest] = stream[_closeRequest];
    stream[_closeRequest] = undefined;
  }
  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
    const writeRequest = stream[_writeRequests].shift();
    stream[_inFlightWriteRequest] = writeRequest;
  }
  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
    if (stream[_closeRequest] !== undefined) {
      rejectPromise(stream[_closeRequest], stream[_storedError]);
      stream[_closeRequest] = undefined;
    }
    const writer = stream[_writer];
    if (writer !== undefined) {
      rejectPromise(writer[_closedPromise], stream[_storedError]);
      markPromiseAsHandled(writer[_closedPromise]);
    }
  }
  function WritableStreamUpdateBackpressure(stream, backpressure) {
    const writer = stream[_writer];
    if (writer !== undefined &&
        backpressure !== Boolean(stream[_stateAndFlags] & BACKPRESSURE_FLAG)) {
      if (backpressure) {
        writer[_readyPromise] = v8.createPromise();
      } else {
        resolvePromise(writer[_readyPromise], undefined);
      }
    }
    if (backpressure) {
      stream[_stateAndFlags] |= BACKPRESSURE_FLAG;
    } else {
      stream[_stateAndFlags] &= ~BACKPRESSURE_FLAG;
    }
  }
  function isWritableStreamErrored(stream) {
    return (stream[_stateAndFlags] & STATE_MASK) === ERRORED;
  }
  function isWritableStreamClosingOrClosed(stream) {
    return WritableStreamCloseQueuedOrInFlight(stream) ||
        (stream[_stateAndFlags] & STATE_MASK) === CLOSED;
  }
  function getWritableStreamStoredError(stream) {
    return stream[_storedError];
  }
  class WritableStreamDefaultWriter {
    constructor(stream) {
      if (!IsWritableStream(stream)) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      if (IsWritableStreamLocked(stream)) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      this[_ownerWritableStream] = stream;
      stream[_writer] = this;
      const state = stream[_stateAndFlags] & STATE_MASK;
      switch (state) {
        case WRITABLE:
        {
          if (!WritableStreamCloseQueuedOrInFlight(stream) &&
              stream[_stateAndFlags] & BACKPRESSURE_FLAG) {
            this[_readyPromise] = v8.createPromise();
          } else {
            this[_readyPromise] = Promise_resolve(undefined);
          }
          this[_closedPromise] = v8.createPromise();
          break;
        }
        case ERRORING:
        {
          this[_readyPromise] = Promise_reject(stream[_storedError]);
          markPromiseAsHandled(this[_readyPromise]);
          this[_closedPromise] = v8.createPromise();
          break;
        }
        case CLOSED:
        {
          this[_readyPromise] = Promise_resolve(undefined);
          this[_closedPromise] = Promise_resolve(undefined);
          break;
        }
        default:
        {
          const storedError = stream[_storedError];
          this[_readyPromise] = Promise_reject(storedError);
          markPromiseAsHandled(this[_readyPromise]);
          this[_closedPromise] = Promise_reject(storedError);
          markPromiseAsHandled(this[_closedPromise]);
          break;
        }
      }
    }
    get closed() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      return this[_closedPromise];
    }
    get desiredSize() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      if (this[_ownerWritableStream] === undefined) {
        throw createWriterLockReleasedError(verbUsedToGetTheDesiredSize);
      }
      return WritableStreamDefaultWriterGetDesiredSize(this);
    }
    get ready() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      return this[_readyPromise];
    }
    abort(reason) {
     if (!IsWritableStreamDefaultWriter(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (this[_ownerWritableStream] === undefined) {
        return Promise_reject(createWriterLockReleasedError(verbAborted));
      }
      return WritableStreamDefaultWriterAbort(this, reason);
    }
    close() {
      if (!IsWritableStreamDefaultWriter(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      const stream = this[_ownerWritableStream];
      if (stream === undefined) {
        return Promise_reject(createWriterLockReleasedError(verbClosed));
      }
      if (WritableStreamCloseQueuedOrInFlight(stream)) {
        return Promise_reject(new TypeError(errCloseCloseRequestedStream));
      }
      return WritableStreamDefaultWriterClose(this);
    }
    releaseLock() {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const stream = this[_ownerWritableStream];
      if (stream === undefined) {
        return;
      }
      WritableStreamDefaultWriterRelease(this);
    }
    write(chunk) {
      if (!IsWritableStreamDefaultWriter(this)) {
        return Promise_reject(new TypeError(streamErrors.illegalInvocation));
      }
      if (this[_ownerWritableStream] === undefined) {
        return Promise_reject(createWriterLockReleasedError(verbWrittenTo));
      }
      return WritableStreamDefaultWriterWrite(this, chunk);
    }
  }
  function IsWritableStreamDefaultWriter(x) {
    return hasOwnProperty(x, _ownerWritableStream);
  }
  function WritableStreamDefaultWriterAbort(writer, reason) {
    const stream = writer[_ownerWritableStream];
    return WritableStreamAbort(stream, reason);
  }
  function WritableStreamDefaultWriterClose(writer) {
    const stream = writer[_ownerWritableStream];
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === CLOSED || state === ERRORED) {
      return Promise_reject(
          createCannotActionOnStateStreamError('close', state));
    }
    const promise = v8.createPromise();
    stream[_closeRequest] = promise;
    if ((stream[_stateAndFlags] & BACKPRESSURE_FLAG) &&
        state === WRITABLE) {
      resolvePromise(writer[_readyPromise], undefined);
    }
    WritableStreamDefaultControllerClose(stream[_writableStreamController]);
    return promise;
  }
  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
    const stream = writer[_ownerWritableStream];
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (WritableStreamCloseQueuedOrInFlight(stream) || state === CLOSED) {
      return Promise_resolve(undefined);
    }
    if (state === ERRORED) {
      return Promise_reject(stream[_storedError]);
    }
    return WritableStreamDefaultWriterClose(writer);
  }
  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(
      writer, error) {
    if (promiseState(writer[_closedPromise]) === v8.kPROMISE_PENDING) {
      rejectPromise(writer[_closedPromise], error);
    } else {
      writer[_closedPromise] = Promise_reject(error);
    }
    markPromiseAsHandled(writer[_closedPromise]);
  }
  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(
      writer, error) {
    if (promiseState(writer[_readyPromise]) === v8.kPROMISE_PENDING) {
      rejectPromise(writer[_readyPromise], error);
    } else {
      writer[_readyPromise] = Promise_reject(error);
    }
    markPromiseAsHandled(writer[_readyPromise]);
  }
  function WritableStreamDefaultWriterGetDesiredSize(writer) {
    const stream = writer[_ownerWritableStream];
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === ERRORED || state === ERRORING) {
      return null;
    }
    if (state === CLOSED) {
      return 0;
    }
    return WritableStreamDefaultControllerGetDesiredSize(
        stream[_writableStreamController]);
  }
  function WritableStreamDefaultWriterRelease(writer) {
    const stream = writer[_ownerWritableStream];
    const releasedError = new TypeError(errReleasedWriterClosedPromise);
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(
        writer, releasedError);
    WritableStreamDefaultWriterEnsureClosedPromiseRejected(
        writer, releasedError);
    stream[_writer] = undefined;
    writer[_ownerWritableStream] = undefined;
  }
  function WritableStreamDefaultWriterWrite(writer, chunk) {
    const stream = writer[_ownerWritableStream];
    const controller = stream[_writableStreamController];
    const chunkSize =
        WritableStreamDefaultControllerGetChunkSize(controller, chunk);
    if (stream !== writer[_ownerWritableStream]) {
      return Promise_reject(createWriterLockReleasedError(verbWrittenTo));
    }
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === ERRORED) {
      return Promise_reject(stream[_storedError]);
    }
    if (WritableStreamCloseQueuedOrInFlight(stream)) {
      return Promise_reject(new TypeError(
          templateErrorCannotActionOnStateStream('write to', 'closing')));
    }
    if (state === CLOSED) {
      return Promise_reject(
          createCannotActionOnStateStreamError('write to', CLOSED));
    }
    if (state === ERRORING) {
      return Promise_reject(stream[_storedError]);
    }
    const promise = WritableStreamAddWriteRequest(stream);
    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
    return promise;
  }
  function getWritableStreamDefaultWriterClosedPromise(writer) {
    return writer[_closedPromise];
  }
  function getWritableStreamDefaultWriterReadyPromise(writer) {
    return writer[_readyPromise];
  }
  class WritableStreamDefaultController {
    constructor(stream, underlyingSink, size, highWaterMark) {
      if (!IsWritableStream(stream)) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      if (stream[_writableStreamController] !== undefined) {
        throw new TypeError(streamErrors.illegalConstructor);
      }
      this[_controlledWritableStream] = stream;
      this[_underlyingSink] = underlyingSink;
      this[_queue] = undefined;
      this[_queueTotalSize] = undefined;
      ResetQueue(this);
      this[_started] = false;
      const normalizedStrategy =
          ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
      this[_strategySize] = normalizedStrategy.size;
      this[_strategyHWM] = normalizedStrategy.highWaterMark;
      const backpressure = WritableStreamDefaultControllerGetBackpressure(this);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    error(e) {
      if (!IsWritableStreamDefaultController(this)) {
        throw new TypeError(streamErrors.illegalInvocation);
      }
      const state =
          this[_controlledWritableStream][_stateAndFlags] & STATE_MASK;
      if (state !== WRITABLE) {
        return;
      }
      WritableStreamDefaultControllerError(this, e);
    }
  }
  function WritableStreamDefaultControllerAbortSteps(controller, reason) {
    return PromiseInvokeOrNoop(controller[_underlyingSink], 'abort', [reason]);
  }
  function WritableStreamDefaultControllerErrorSteps(controller) {
    ResetQueue(controller);
  }
  function WritableStreamDefaultControllerStartSteps(controller) {
    const startResult =
        InvokeOrNoop(controller[_underlyingSink], 'start', [controller]);
    const stream = controller[_controlledWritableStream];
    const startPromise = Promise_resolve(startResult);
    thenPromise(
        startPromise,
        () => {
          const state = stream[_stateAndFlags] & STATE_MASK;
          controller[_started] = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        },
        r => {
          const state = stream[_stateAndFlags] & STATE_MASK;
          controller[_started] = true;
          WritableStreamDealWithRejection(stream, r);
        });
  }
  function IsWritableStreamDefaultController(x) {
    return hasOwnProperty(x, _underlyingSink);
  }
  function WritableStreamDefaultControllerClose(controller) {
    EnqueueValueWithSize(controller, 'close', 0);
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
    const strategySize = controller[_strategySize];
    if (strategySize === undefined) {
      return 1;
    }
    let value;
    try {
      value = Function_call(strategySize, undefined, chunk);
    } catch (e) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, e);
      return 1;
    }
    return value;
  }
  function WritableStreamDefaultControllerGetDesiredSize(controller) {
    return controller[_strategyHWM] - controller[_queueTotalSize];
  }
  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
    const writeRecord = {chunk};
    try {
      EnqueueValueWithSize(controller, writeRecord, chunkSize);
    } catch (e) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, e);
      return;
    }
    const stream = controller[_controlledWritableStream];
    if (!WritableStreamCloseQueuedOrInFlight(stream) &&
        (stream[_stateAndFlags] & STATE_MASK) === WRITABLE) {
      const backpressure =
          WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }
  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
    const stream = controller[_controlledWritableStream];
    if (!controller[_started]) {
      return;
    }
    if (stream[_inFlightWriteRequest] !== undefined) {
      return;
    }
    const state = stream[_stateAndFlags] & STATE_MASK;
    if (state === CLOSED || state === ERRORED) {
      return;
    }
    if (state === ERRORING) {
      WritableStreamFinishErroring(stream);
      return;
    }
    if (controller[_queue].length === 0) {
      return;
    }
    const writeRecord = PeekQueueValue(controller);
    if (writeRecord === 'close') {
      WritableStreamDefaultControllerProcessClose(controller);
    } else {
      WritableStreamDefaultControllerProcessWrite(controller,
                                                  writeRecord.chunk);
    }
  }
  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
    const state =
        controller[_controlledWritableStream][_stateAndFlags] & STATE_MASK;
    if (state === WRITABLE) {
      WritableStreamDefaultControllerError(controller, error);
    }
  }
  function WritableStreamDefaultControllerProcessClose(controller) {
    const stream = controller[_controlledWritableStream];
    WritableStreamMarkCloseRequestInFlight(stream);
    DequeueValue(controller);
    const sinkClosePromise = PromiseInvokeOrNoop(
        controller[_underlyingSink], 'close', []);
    thenPromise(
        sinkClosePromise,
        () => WritableStreamFinishInFlightClose(stream),
        reason => WritableStreamFinishInFlightCloseWithError(stream, reason)
        );
  }
  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
    const stream = controller[_controlledWritableStream];
    WritableStreamMarkFirstWriteRequestInFlight(stream);
    const sinkWritePromise = PromiseInvokeOrNoop(controller[_underlyingSink],
                                                 'write', [chunk, controller]);
    thenPromise(
        sinkWritePromise,
        () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream[_stateAndFlags] & STATE_MASK;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) &&
              state === WRITABLE) {
            const backpressure =
                WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        },
        reason => {
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
  }
  function WritableStreamDefaultControllerGetBackpressure(controller) {
    const desiredSize =
        WritableStreamDefaultControllerGetDesiredSize(controller);
    return desiredSize <= 0;
  }
  function WritableStreamDefaultControllerError(controller, error) {
    const stream = controller[_controlledWritableStream];
    WritableStreamStartErroring(stream, error);
  }
  function DequeueValue(container) {
    const pair = container[_queue].shift();
    container[_queueTotalSize] -= pair.size;
    if (container[_queueTotalSize] < 0) {
      container[_queueTotalSize] = 0;
    }
    return pair.value;
  }
  function EnqueueValueWithSize(container, value, size) {
    size = Number(size);
    if (!IsFiniteNonNegativeNumber(size)) {
      throw new RangeError(streamErrors.invalidSize);
    }
    container[_queue].push({value, size});
    container[_queueTotalSize] += size;
  }
  function PeekQueueValue(container) {
    const pair = container[_queue].peek();
    return pair.value;
  }
  function ResetQueue(container) {
    container[_queue] = new binding.SimpleQueue();
    container[_queueTotalSize] = 0;
  }
  function InvokeOrNoop(O, P, args) {
    if (args === undefined) {
      args = [];
    }
    const method = O[P];
    if (method === undefined) {
      return undefined;
    }
    if (typeof method !== 'function') {
      throw new TypeError(templateErrorIsNotAFunction(P));
    }
    return Function_apply(method, O, args);
  }
  function IsFiniteNonNegativeNumber(v) {
    return Number_isFinite(v) && v >= 0;
  }
  function PromiseInvokeOrNoop(O, P, args) {
    try {
      return Promise_resolve(InvokeOrNoop(O, P, args));
    } catch (e) {
      return Promise_reject(e);
    }
  }
  function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
    if (size !== undefined && typeof size !== 'function') {
      throw new TypeError(streamErrors.sizeNotAFunction);
    }
    highWaterMark = Number(highWaterMark);
    if (Number_isNaN(highWaterMark)) {
      throw new RangeError(streamErrors.invalidHWM);
    }
    if (highWaterMark < 0) {
      throw new RangeError(streamErrors.invalidHWM);
    }
    return {size, highWaterMark};
  }
  defineProperty(global, 'WritableStream', {
    value: WritableStream,
    enumerable: false,
    configurable: true,
    writable: true
  });
  binding.AcquireWritableStreamDefaultWriter =
      AcquireWritableStreamDefaultWriter;
  binding.IsWritableStream = IsWritableStream;
  binding.isWritableStreamClosingOrClosed = isWritableStreamClosingOrClosed;
  binding.isWritableStreamErrored = isWritableStreamErrored;
  binding.IsWritableStreamLocked = IsWritableStreamLocked;
  binding.WritableStreamAbort = WritableStreamAbort;
  binding.WritableStreamDefaultWriterCloseWithErrorPropagation =
      WritableStreamDefaultWriterCloseWithErrorPropagation;
  binding.getWritableStreamDefaultWriterClosedPromise =
      getWritableStreamDefaultWriterClosedPromise;
  binding.WritableStreamDefaultWriterGetDesiredSize =
      WritableStreamDefaultWriterGetDesiredSize;
  binding.getWritableStreamDefaultWriterReadyPromise =
      getWritableStreamDefaultWriterReadyPromise;
  binding.WritableStreamDefaultWriterRelease =
      WritableStreamDefaultWriterRelease;
  binding.WritableStreamDefaultWriterWrite = WritableStreamDefaultWriterWrite;
  binding.getWritableStreamStoredError = getWritableStreamStoredError;
});
 dummy<(function() {})